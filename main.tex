% Created 2024-03-22 Fri 18:04
% Intended LaTeX compiler: pdflatex
\documentclass[11pt,a4paper,final]{article}
\usepackage[a4paper, total={7in, 10in}]{geometry}
\usepackage{booktabs}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{subcaption}                     % Subfigures
\usepackage[ruled]{algorithm2e}             % Algorithms
\usepackage{xcolor}                         % Color time
\usepackage{listings}                       % Code in LaTeX
\usepackage{listings-rust}                  % Code in LaTeX
\usepackage{amsfonts}                       % Cool math fonts
\usepackage{tabularx}                       % Cool tables
\usepackage{multicol}                       % Add capability to make columns
\usepackage{soul}                           % Highlight text
\usepackage[stable]{footmisc}               % Allow footnotes in section headers
\usepackage{hyperref}                       % Cool clean hyperlinks
\setlength\parindent{0pt}                   % No indent for paragraphs
\lstset{language=Rust, style=boxed}
\usetikzlibrary{arrows.meta}                % Arrows for tikz
\renewcommand*{\sectionautorefname}{Section}
\renewcommand*{\subsectionautorefname}{Section}
\renewcommand*{\subsubsectionautorefname}{Section}
\renewcommand*{\paragraphautorefname}{Section}
\renewcommand*{\algorithmautorefname}{Algorithm}
\newcommand{\Or}{\textbf{ or }}
\renewcommand*{\And}{\textbf{ and }}
\newcolumntype{L}[1]{>{\hsize=#1\hsize\raggedright\arraybackslash}X}%
\newcommand{\mathcolorbox}[1]{\colorbox{yellow}{$\displaystyle #1$}}
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{gray}{#1}}
\newcommand{\T}{\mathcal{T}}                % To make it clear the difference
\newcommand{\Tau}{T}                        % between Tau and T
\newcommand{\AC}{AC(u, d, v, \eta)}         % Set the parameters for AC once
\newcommand{\UC}{UC(u, d, v)}               % Set the parameters for UC once
\newcommand{\ACi}{AC(u_i, d_i, q_i, \eta_i)}% Set the parameters for AC once
\newcommand{\UCi}{UC(u_i, d_i, q_i)}        % Set the parameters for UC once
\newcommand{\Not}{\textbf{not }}            % Custom `not' operator
\newcommand{\visit}{(i, b, a, e, u, d, q, \eta, \xi)}
\newcommand{\I}{\mathbb{I}}                 % Set of visit tuples
\newcommand{\C}{\mathbb{C}}                 % Charger availability information
\newcommand{\U}{\mathcal{U}}                % Uniform distribution
\newcommand{\W}{\mathcal{W}}                % Weighted distribution
\newcommand{\Sol}{\mathbb{S}}               % A shorthand for visit tuple
\newcommand{\M}{\mathbb{M}}                 % A shorthand for the metadata
\newcommand{\Hd}{\mathbb{H}}                % Set of discrete times
\newcommand{\Nu}{\mathcal{V}}               % Draw a nice Nu
\newcommand{\Iset}{I}                       % Set of visits 1-I
\newcommand{\Isetinit}{I_0}                 % Set of visits inital visits
\newcommand{\Isetfinal}{I_f}                % Set of visits final visits
\newcommand{\Bset}{B}                       % Set of visits 1-B
\newcommand{\Qset}{Q}                       % Set of visits 1-Q
\newcommand{\Jset}{J}                       % Set of visits 1-J
\newcommand{\Jsetq}{\mathbb{J}}             % Set of visits 1-J for queue active times
\newcommand{\Hset}{H}                       % Set of visits 1-H
%%-------------------------------------------------------------------------------
% Experiment parameters
\newcommand{\A}{35 }                                                            % Number of buses
\newcommand{\N}{338 }                                                           % Number of visits
\newcommand{\Cgain}{5000}                                                       % Gain applied to penalty method
\newcommand{\acharge}{0.9}                                                      % BOD charge percentage
\newcommand{\bcharge}{0.7 }                                                     % EOD charge percentage
\newcommand{\mincharge}{25\% }                                                  % Min visit charge percent
\newcommand{\minchargeD}{0.25 }                                                 % Min visit charge decimal
\newcommand{\maxcharge}{100\% }                                                 % Max visit charge percent
\newcommand{\batsize}{388 }                                                     % Battery capacity
\newcommand{\fast}{15 }                                                         % Number of fast chargers
\newcommand{\slow}{15 }                                                         % Number of slow chargers
\newcommand{\fasts}{911 }                                                       % Speed of fast charger
\newcommand{\slows}{30 }                                                        % Speed of slow charger
\newcommand{\contvars}{7,511 }
\newcommand{\intvars}{328,282 }
\newcommand{\localcnt}{500 }                                                    % Number of local search iterations
\newcommand{\tempinit}{9000 }                                                   % Initial temperature
\newcommand{\tempcnt}{9101 }                                                    % Number of steps in temperature
\newcommand{\quicklocal}{0.25 }                                                % Time to finish local quick
\newcommand{\heuristiclocal}{0.4 }                                             % Time to finish local heuristic
%%-------------------------------------------------------------------------------
%% Solve output
%% Solve output
\newcommand{\timeran}{4.2 }                                                    % Time ran for MILP [s]
\author{Alexander Brown}
\date{\today}
\title{Bus Charging Schedule Simulated Annealing with MILP Constraints}
\hypersetup{
 pdfauthor={Alexander Brown},
 pdftitle={Bus Charging Schedule Simulated Annealing with MILP Constraints},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 29.2 (Org mode 9.6.15)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents

\parskip 3mm                                % Set the vetical space between paragraphs
\let\ref\autoref                            % Redifine `\ref` as `\autoref` because lazy
\SetCommentSty{mycommfont}                  % Set the comment color

\section{Introduction}
\label{sec:introduction}
Public transportation systems are a critical component urban areas. An increased awareness and concern of environmental
impacts of petroleum based public transportation has driven an effort to reduce the pollutant footprint
\cite{de-2014-simul-elect,xylia-2018-role-charg,guida-2017-zeeus-repor-europ,li-2016-batter-elect}. Particularly,
the electrification of public bus transportation via battery power, i.e., battery electric buses (BEBs), has received
significant attention \cite{li-2016-batter-elect}. Although the technology provides benefits beyond reduction in
emissions, such as lower driving costs, lower maintenance costs, and reduced vehicle noise, battery powered systems
introduce new challenges such as larger upfront costs, and potentially several hours long ``refueling'' periods
\cite{xylia-2018-role-charg,li-2016-batter-elect}. Furthermore, the problem is exacerbated by the constraints of the
transit schedule to which the fleet must adhere, the limited amount of chargers available, and the adverse affects in
the health of the battery due to fast charging \cite{lutsey-2019-updat-elect}.

BEBs have been in service for many major markets, North America, Europe, and China, for more than a decade with expected
growth in the near future \cite{deng-2021-survey-elect}. The Asia Pacific market is forecasted to dominate the sales
and some major companies of the industry have also begun to enter the global market such as Volvo, BYD, and Proterra by
2025 \cite{deng-2021-survey-elect}. Much focus has been placed on the engineering of individual BEBs, such as: battery
type, brake regenerative charging, optimal battery charging, and battery degradation \cite{chen-2008-desig-grey,abdollahi-2016-optim-batter,kuhne-2010-elect,deng-2021-survey-elect}. The interest of route scheduling, charging
fleets, and optimizing the infrastructure are problems of more recent interest and are therefore timely and increasingly
relevant problems as EV/BEBs become more commonplace \cite{hoke-2014-accoun-lithium,sebastiani-2016-evaluat-elect,wei-2018-optim-spatio}. This paper presents a scheduling framework for a BEB fleet that allows for multiple charger
types and partial charging. It considers linear battery dynamics, fixed bus schedules, and enforces a state-of-charge
(SOC) threshold while taking into consideration energy consumed by the system as well as peak power use.

Literature shows an interest in solving the problem of assigning BEBs to charging queues or optimizing their
infrastructure \cite{wei-2018-optim-spatio,sebastiani-2016-evaluat-elect,hoke-2014-accoun-lithium,wang-2017-elect-vehic}. Two of the main problems that have been of recent interest are
solving the problems of route scheduling, charging fleets, and determining the infrastructure upon which they rely.
Additionally, the prospect of solving both problems simultaneously has received much attention
\cite{wei-2018-optim-spatio,sebastiani-2016-evaluat-elect,hoke-2014-accoun-lithium,wang-2017-elect-vehic}. These
problems vary by including assignment of buses to routes \cite{rinaldi-2020-mixed-fleet,zhou-2020-collab-optim,tang-2019-robus-sched,li-2014-trans-bus}, determining whether a set of existing combustion based buses should be
replaced with BEBs \cite{zhou-2020-bi-objec,duan-2021-refor-mixed,rinaldi-2020-mixed-fleet,zhou-2020-collab-optim}, and accounting for uncertainties \cite{bie-2021-optim-elect,duan-2021-refor-mixed,tang-2019-robus-sched,ursavas-2016-optim-polic}. These problems add additional complexities that warrant
simplifications due to computational complexities. One other source, as far as the reseach for this work has shown,
describes a method of producing a BEB charge schedule wih a high fidelity while accounting for multiple charger times as
well as being able to minimize over the total charger count \cite{whitaker-2023-a-network}.

Some works assume that the charge received is proportional to the time spent on the charger
\cite{liu-2020-batter-elect,yang-2018-charg-sched}. While the linear battery dynamics is a valid assumption when the
battery SOC is below 80\% \cite{liu-2020-batter-elect}, non-linear battery dynamics can be implemented to more
accurately model the charge curve. A common way to model the non-linear battery dynamics is utilizing Constant Voltage
(CV), Constant Current (CC), and Constant Current Constant Voltage (CCCV) \cite{abdollahi-2016-optim-batter,chen-2008-desig-grey}. It has also been suggested that the dynamics can be modeled as a piecewise function containing a
linear and non-linear component from which the CV and CC models construct the linear and non-linear parts, respectively
\cite{zhang-2021-optim-elect,abdollahi-2016-optim-batter}. Others have modeled the battery dynamics as a discrete
first order dynamics model \cite{whitaker-2023-a-network}. The first-order differential system, when provided a step
input, approximates the non-linear relationship between time and SOC \cite{whitaker-2023-a-network}. While framework
presented in this work may implement the non-linear battery dynamics model, linear battery dynamics are chosen to allow
comparisons between other solution methods.

Works concerning charge planning often use a version of the vehicle scheduling problem \cite{tang-2019-robus-sched,li-2014-trans-bus,he-2020-optim-charg}. Variants of this problem address infrastructure as well as determining
existing buses that should be replaced by a BEB \cite{zhou-2020-bi-objec,duan-2021-refor-mixed,rinaldi-2020-mixed-fleet,zhou-2020-collab-optim}. Other works introduce a directed graph approach to model the flow
of BEBs \cite{whitaker-2023-a-network,liu-2020-batter-elect}, where this concept was expanded to simultaneously
accounting for multiple charger types, partial charging, non-linear battery charge profiles
\cite{whitaker-2023-a-network}. The directed graph approach provides a simple method of modeling the scheduling by
discretizing the time horizon into a sequence of nodes for each charger. The nodes represent discrete steps in time in
which BEBs may be assigned to be charged. BEBs may be assigned to sequential time steps of a singular charger. Once it
has completed its charge, the BEB is then transitioned out of the charge queue creating an opening for another BEB to
receive charge.

Another method similar to the directed graph that fits the modeling of the BEB charging scenario is the Position
Allocation Problem (PAP) \cite{qarebagh-2019-optim-sched}. The PAP is derived from the Berth Allocation Problem (BAP)
which solves the problem of scheduling a set of vessels to be berthed and serviced. The model inputs a set of vessels
arrival and service times and outputs a schedule that defines the selected berth and the time over which it is serviced.
The PAP utilizes this model and redefines its inputs to EV arrival times and outputs queues for the EVs to be charged.
While the visits remain as discrete events, the time that the BEB is on the charger is modeled as continuous, similar to
\cite{frojan-2015-contin-berth,qarebagh-2019-optim-sched,zhou-2020-collab-optim}. Due to the close relationship
between the BAP and PAP, BAP literature may be used for the PAP. The literature shows methods of handling multiple quays
(sets of chargers) to handle general berthing scenarios \cite{frojan-2015-contin-berth,dai-2008-suppl-chain-analy}.
Heuristic procedures for quicker solve times have also been introduced \cite{imai-2001-dynam-berth}. Methods of
defining static (full time horizon) and dynamic (rolling-time horizon) models have been created for daily and real-time
solutions, respectively, and even fuzzy set theory has been applied to allow for more flexible schedules
\cite{bello-2019-fuzzy-activ,dai-2008-suppl-chain-analy,buhrkal-2011-model-discr,frojan-2015-contin-berth}. This
work utilizes an extension of the PAP as the basis of determining the feasible space of candidate solutions.

To the best of our knowledge, there are two other works that schedule BEB fleets while allowing multiple charger types,
charger, partial charging, and accounting for consumption costs \cite{whitaker-2023-a-network}(MILP PAP). One of which
utilizing non-linear battery dynamics and competition over chargers \cite{whitaker-2023-a-network}, and the other
utilizing linear battery dynamics and minimizing the total charger count (MILP PAP). This paper expands on these
previous works by introducing a simulated annealing (SA) framework that utilizes linear battery dynamics, minimizes the
total charger count, consumption cost, and peak power use (demand cost).

In what follows, the problem statement shall be provided in \ref{sec:problem-description}. \ref{sec:optimization-problem}
introduces the structure of the MILP formulation as well as a description of the parameters, decision variables,
objective function and constraints. In \ref{sec:simulated-annealing}, the concept and theory of SA is introduced. In
particular the algorithms and methods utilized for the SA implementation for this work are discussed.
\ref{sec:optimization-algorithm} outlines a generic SA algorithm, and then combines the previous sections to introduce the
particular implementation for the SA-PAP. In \ref{sec:example}, an example problem is provided to demonstrate the capability
of the work provided in this paper. The results will be presented and discussed.
\section{Problem Description}
\label{sec:problem-description}
Consider a fleet of BEBs scheduled to perform a set of prescribed routes on a given day. An individual BEB from said
fleet begins and completes an individual route at the same station from which it also receives its charge. During each
route, the BEB's State of Charge (SOC) is depleted by a certain amount. The charge supplied during its visit must be
enough to sustain the BEB's SOC at an appropriate level so that it may complete its next route. The charge may be
supplied from any single charger given a set of chargers at the station. Let the term ``arrival'' describe the time at
which a BEB reaches the station. Furthermore, let the term ``visit'' denote a BEB having arrived, awaited its
predetermined time (whether it has received a charge or not), and departed from the station. Each BEB may have multiple
visits to the station throughout their working day. This paper describes a method to optimize the assignment of each
visit to a charger given a schedule for a fleet of BEBs that follow the behavior described above. The model presented in
this work optimizes over peak power usage and energy consumption, as well as attempts to optimize the amount of chargers
utilized.

Consider a fleet of \(n_B\) BEBs that collectively visit a station \(n_V\) times. At said station, let there exist a pool of
\(n_Q\) charging queues from which a visiting BEB may be assigned. Let \(\mathbb{Z}\) define the set of integers. The pool of queues
from which a BEB may be placed is \(\Qset \subset \mathbb{Z}\) is defined by letting the first \(n_B\) queues be denoted as idle queues
followed by slow and then fast chargers. The term idle queues is meant to signify queues that provide no charge to the
BEB. The next \(n_Q\) queues are chargers ordered from slow to fast. Furthermore, let the set of arrivals be denoted as
\(\Iset = \{ 1, ... n_V \} \subset \mathbb{Z}\). Each BEB is provided an identification number in the set \(B = \{ 1, ..., n_B \} \subset \mathbb{Z}\).
Each visit can be represented by the tuple: \(\visit\), in which the elements within the tuple denote the visit index, \(i
\in I\), BEB identification number, \(b \in B\), arrival time to the station, \(a \in \mathbb{R}\), departure time from the station, \(e \in
\mathbb{R}\), time at which the BEB begins charging, \(u \in \mathbb{R}\), time at which the BEB ends charging, \(d \in \mathbb{R}\), the charger queue for
the BEB to be placed into, \(q \in Q\), the SOC upon arrival, \(\eta \in \mathbb{R}\), and the index of the next visit for the currently
visiting BEB, \(\xi \in I \cup \varnothing\). The null element, \(\varnothing\), is used to specify when a BEB has no future
visits. Let the ordered set of visits be denoted as \(\I\) where the \(i^{\text{th}}\) visit is denoted is \(\I_i\).
Furthermore, let a particular item from the tuple for visit \(i\) to be written as \(\cdot_i\). For example, the arrival time
for visit \(i\) is written as \(a_i\).

At each visit, the associated BEB is placed into a single queue corresponding to a particular charger. The charger is
assumed to be either an idle queue, slow charger, or fast charger. A BEB is only allowed to be assigned to one queue per
visit; however, there may be multiple BEBs charging simultaneously across different queues. The amount of time the BEB
is allowed to charge during visit \(i\) is dictated by the scheduled arrival time and required departure time, \([a_i,
e_i]\). Partial charging is allowed; however, the SOC may not exceed the BEB battery capacity and the SOC must stay above
0\%. The battery dynamics in this work is modeled as linear, which remains accurate up to about an SOC of 80\% charge
\cite{liu-2020-batter-elect}. Note that charging beyond the 80\% SOC threshold is undesirable due to batter health
concerns.

Each BEB arrival, except for the last arrival for each BEB, has a paired ``route'' that the BEB must perform after the
visit. This route, as one would expect, causes the BEB to discharge by some certain amount. Each bus is assumed to have
a fixed discharge. Let the discharge of the route for visit \(i\) be denoted as \(\Delta_i \in \mathbb{R}\). Each bus has a desired minimum
battery percentage, \(\nu_b \in [0, 1]\).

\begin{figure}[ht!]
  \centering
  \scalebox{0.5}{
  \centerline{
    \begin{tikzpicture}
      % Variables
      \def \arrx   {2.0}
      \def \initx  {3.5}
      \def \endx   {8.5}
      \def \depx   {10.0}
      \def \yshift {5}

      % Axis
      \draw [thick,<->] (0,15) node[above]{Queues} -- (0,0) -- (15,0) node[right]{Time};

      % Rectangles
      \node[rectangle, draw, fill=gray, minimum width=4cm, minimum height = 3cm] at (3,12) {A};
      \node[rectangle, draw, fill=gray, minimum width=3cm, minimum height = 3cm] at (9,12) {B};
      \node[rectangle, draw, fill=gray, minimum width=5cm, minimum height = 3cm] at (6,7) {D};
      \node[rectangle, draw, fill=gray, minimum width=6cm, minimum height = 3cm] at (12,2) {C};

      % X-axis labels
      \node [below,align=center] at (\arrx,0) {\scriptsize Arrival     \\ \scriptsize Time \\ $a_D$};
      \node [below, align=center] at (\initx,0) {\scriptsize Charge    \\ \scriptsize Initiation  \\ $u_D$};
      \node [below, align=center] at (\endx,0) {\scriptsize Charge     \\ \scriptsize End \\ $d_D$};
      \node [below, align=center] at (\depx,0) {\scriptsize Departure  \\ \scriptsize Time \\ $e_D$};

      % Y-axis labels
      \node[rotate=90] at (-1, 2.25) {Queue 1};
      \node[rotate=90] at (-1, 7.25) {Queue 2};
      \node[rotate=90] at (-1, 12.25) {Queue 3};

      % Vertical lines
      \draw[dashed] (\arrx,\yshift)--(\arrx,0);
      \draw[dashed] (\initx,\yshift)--(\initx,0);
      \draw[dashed] (\endx,\yshift)--(\endx,0);
      \draw[dashed] (\depx,\yshift)--(\depx,0);

      % Horizontal lines
      \draw[dotted] (0, 4.5) -- (15, 4.5);
      \draw[dotted] (0, 9.5) -- (15, 9.5);

    \end{tikzpicture}
  }}
  \caption{The representation of the queue-time space. The x and y-axis represent time and space, respectively. Along the y-axis, the dashed lines represent discrete queuing locations. The shaded rectangles represent schedules BEBs to be charged. The height of each shaded rectangle represents the space taken on the queue and the width being the time to service said BEB. The vertical dashed lines are associated with vessel D and represent the arrival time, initial charge time, charge completion time, and departure time. Note that the arrival time may be before the initial charge time and the completion time may before the departure time.}
  \label{fig:spacial-and-temporal-constr}
\end{figure}
\section{Optimization Problem}
\label{sec:optimization-problem}
The problem outlined in this work is presented in the form of an objective function with MILP constraints. The MILP
constraints ensure that candidate solutions are operationally feasible. The optimization variables are introduced in
\ref{sec:parameter-definitions}. The objective function is broken down into four major components: consumption cost, demand
cost, assignment cost, and under-charging cost (i.e. a penalty for not meeting minimum charge requirements). The
constraints will then be introduced in \ref{sec:constraints}. The objective function is introduced in
\ref{sec:objective-function}.

\subsection{Variable Definitions}
\label{sec:parameter-definitions}
This section defines the input and decision variables used by the system. The input parameters are assumed to be fixed
prior to optimizing the system. The decision variables are the values that the SA algorithm has the freedom to
manipulate. The variables to be introduced are summarized in \ref{tab:variables}.

\subsubsection{Input Parameters}
\label{sec:input-variables}
The parameters are assumed to be known prior to optimization. They will be presented in two sections: battery dynamics
parameters then packing and discretization parameters. The Battery dynamic parameters are those associated with the SOC
of the BEB, the packing and discretization parameters are those that are associated with BEB placement and the method of
discretizing the system.

\paragraph{Battery Dynamic Parameters}
\label{sec:battery-dynamic-parameters}
The amount energy required to complete the bus route after visit \(i\) is denoted as \(\Delta_i\). There are no routes after the
last visit for each BEB; thus; the energy consumed after the final visit is zero. Let the set of final visits for all
BEBs be denoted as \(\Isetfinal\). That is, the cardinality of the set is \(\lvert \Isetfinal \rvert = n_B\) where \(i \in
\Isetfinal \subset \Iset\) specifies the index for the final visit of bus. The discharge for the final visit of each BEB is
then defined as \(\Delta_{i} = 0; \forall i \in \Isetfinal\). The initial SOC percentage of bus \(b\) at the beginning of the working day
is denoted as \(\alpha_b\). Let \(\Isetinit\) denote the set of initial visit indices for each BEB and let \(\Xi_i \in B\) denote the
identification number of the BEB for visit \(i\). The initial SOC for bus \(\Xi_i\) can be represented as \(\eta_{i} =
\alpha_{\Xi_i}\kappa_{\Xi_i}; \forall i \in \Isetinit \subset \Iset\) where \(\kappa_{\Xi_i}\) is the battery capacity for bus \(\Xi_i\). Lastly, \(r_q\) represents
the power supplied from the charger in queue \(q \in Q\).

\paragraph{Packing and Discretization Parameters}
\label{sec:packing-and-discretization-paramaters}
The cost for assigning a charger to queue \(q \in Q\) is defined by \(\epsilon_q\). \(\xi_i\) represents the next arrival index for bus
\(b_i\). In other words, suppose the ID of each BEB is recorded in order of arrival. Further suppose that recorded list is
\(\xi = \{ 2,1,3,2 \}\), using a starting index of 1, \(\xi_1 = 4\) as that is the next visit by bus 2. The arrival and
departure times of bus visit \(i\) to the station are denoted as \(a_i\) and \(e_i\), respectively. The notation \(t_h\) is used
to denote a discrete time that is employed to calculate the demand cost. \(dt_h\) is the discrete time step \(dt_h = t_h -
t_{h-1}\).

\begin{table}[htbp]
\caption{\label{tab:variables}Table of variables used in the paper.}
\centering
\begin{tabularx}{\textwidth}{L{0.3} L{1.2} L{0.3} L{1.2}}
\textbf{Variable} & \textbf{Description} & \textbf{Variable} & \textbf{Description}\\[0pt]
\hline
Constants &  & Constants & \\[0pt]
\(D\) & Penalty method gain factor & \(n_B\) & Number of buses in use\\[0pt]
\(\T\) & Time horizon & \(n_K\) & Number of iterations in the repetition schedule\\[0pt]
\(n_M\) & Total number of steps created by initial temperature, \(\Tau_0\), and cooling schedule & \(n_Q\) & Number of chargers\\[0pt]
\(n_V\) & Total number of visits & \(n_h\) & Number of discrete steps in time horizon\\[0pt]
\hline
Input variables &  & Input Variables & \\[0pt]
\(\Delta_i\) & Discharge of visit over after visit \(i\) & \(\alpha_b\) & Initial charge percentage time for bus \(b\)\\[0pt]
\(\epsilon_q\) & Cost of using charger \(q\) & \(\kappa_b\) & Battery capacity for each BEB\\[0pt]
\(\rho_i\) & Duration for route after visit \(i\) & \(\xi_i\) & The next index bus \(b\) will arrive\\[0pt]
\(a_i\) & Arrival time of visit \(i\) & \(\Xi_i\) & ID for bus visit \(i\)\\[0pt]
\(t_h\) & Discrete step in time horizon & \(dt_h\) & Discrete time slice in time horizon \(dt_h = t_h - t_{h-1}\)\\[0pt]
\(k\) & Local search iteration \(k\) & \(e_i\) & Time bus visit \(i\) must exit the station\\[0pt]
\(r_q\) & Charge rate of charger \(q\) & \(t_m\) & Element of the temperature vector created by temperature function, \(t_m \in t\)\\[0pt]
\(\nu_b\) & Minimum charge percentage allowed for each BEB &  & \\[0pt]
\hline
Direct Decision Variables &  & Direct Decision Variables & \\[0pt]
\(u_i\) & Initial charge time for visit \(i\) & \(d_i\) & Final charge time for charger for visit \(i\)\\[0pt]
\(q_i\) & Assigned queue for visit \(i\) &  & \\[0pt]
Indirect Decision Variables &  & Indirect Decision Variables & \\[0pt]
\(\eta_i\) & Charge for the bus upon arrival visit \(i\) & \(s_i\) & Amount of time spent on charger for visit \(i\)\\[0pt]
\(\sigma_{ij}\) & Binary variable determining temporal ordering of vehicles \(i\) and \(j\) & \(\psi_{ij}\) & Binary variable determining spatial ordering of vehicles \(i\) and \(j\)\\[0pt]
\(p_{d}\) & Demand cost of the schedule & \(\phi_i\) & Penalty method for visit \(i\)\\[0pt]
\(\C\) & Set of available charging times &  & \\[0pt]
\hline
\end{tabularx}
\end{table}

\subsubsection{Decision Variables}
\label{sec:decision-variables}
Decision variables are those chosen by the optimizer. The variables will be broken into two sections: direct and slack
variables. Direct decision variables are those that the system manipulates directly, and slack variables are those that
are functions of the direct.

\paragraph{Direct Decision Variables}
\label{sec:direct-decision-variables}
The first two variables are \(u_i\) and \(d_i \; \forall i \in \Iset\). They represent the initial and final charging times. These
values must remain within range of the arrival and departure times, \([a_i, e_i]\), for visit \(i\). The last direct
decision variable is the queue that bus visit \(i\) can be placed in to charge, \(q_i \in \Qset\).

\paragraph{Slack Variables}
\label{sec:slack-decision-variables}
Let the initial SOC for a visit be written as \(\eta_i\), where \(i \in \Iset \setminus \Iset_0\). The initial charge for visit \(i\) forms
the foundation from which the SOC of the next visit, \(\eta_{\xi_i}\), is calculated. The charge for bus \(i\)'s next visit is
equal to the initial charge for visit \(i\) plus the charge added to it by charger \(q_i\) over duration \(s_i = d_i - u_i\)
minus the discharge accumulated over route \(i\), i.e.

\begin{equation}
\label{eq:bat-chain}
  \eta_{\xi_i} = \eta_i + r_{q_i}s_i - \Delta_i\text{.}
\end{equation}

The variables \(\sigma_{ij}\) and \(\psi_{ij}\) are used to indicate whether a visit pair \((i, j)\) overlap the same space, as show
in \ref{fig:overlap}. These spatiotemporal variables uphold the following relationships:

\begin{subequations}
\label{eq:bus-spat-temp}
\begin{equation}
  \sigma_{ij} =
  \begin{cases}
    1 & \text{if } u_j \ge d_i, \; i \ne j\\
    0 & \text{otherwise}
  \end{cases}
\end{equation}

\begin{equation}
  \psi_{ij} =
  \begin{cases}
    1 & \text{if } q_j \ge q_i,\; i \ne j\\
    0 & \text{otherwise}
  \end{cases}
\end{equation}
\end{subequations}

That is, for every visit, \(\sigma_{ij} = 1 \implies\) the start charge time of visit \(j\) is greater than the end charge time
of visit \(i\). Similarly, \(\psi_{ij} = 1 \implies\) the queue for visit \(j\) is of a greater index than visit \(i\).

The variable \(\C\) is the set that describes the availability for all chargers. That is, \(\C\) is a set of \(n_Q\) sets that
contain available charger times for each queue \(q \in Q\). Let a set of available charge times for queue \(q\) be defined as
\(\C_q\).

\subsection{Objective Function}
\label{sec:objective-function}
This work aims to minimize the total ``cost'' of utilizing a given charge schedule. Let \(J(\I)\) represent the objective
function. The objective function for this problem has four main considerations: charger assignment, consumption cost,
demand cost, and penalty for an insufficient initial SOC. Each of which will be discussed in turn in the subsequent
sections.

\subsubsection{Assignment Cost}
\label{sec:assignment-cost}
The assignment cost represents the costs of assigning a bus to a particular queue. This is done as a method of
minimizing the total utilized chargers. The assignment cost is written as

\begin{equation}
\label{eq:assignment-cost}
\sum_{i=1}^{n_V} \epsilon_{q_i}r_{q_i}\text{.}
\end{equation}

This cost is effectively the cost on the choice of \(q\). Recalling the form of \(Q\), particularly the ordering in which
the set was defined. Taking \(\epsilon\) to be constructed using the same ordering (idle, slow, then fast charging queues), let
the first \(n_B\) queues have no cost. Furthermore, let the next \(n_Q\) charging queues be of the form \([P, 2P, ...,
n_QP]\). Concatenating these vectors yields \(\epsilon = [[0; n_B], [P, 2P, ..., Pn_Q]]\), where \([0; n_B]\) is used to denote a
vector populated with zeros of length \(n_B\). In words, this form accrues no cost when assigning a BEB to an idle queue
while still minimizing charger count and encouraging the use of slow chargers over fast. Thus, the larger the index of
\(q\), the larger the cost. The \(\epsilon\) vector described above is one of many forms that the vector may take; however, form
shown described is what is applied in this work.

\subsubsection{Penalty Method}
\label{sec:penalty-method}
A penalty method is to be implemented in the objective function that is enabled when the \(\eta_i\) falls below a defined
threshold. Let the piecewise function that enables/disables the penalty method be of the form

\begin{equation}
\label{eq:penalty}
  \phi(x) =
  \begin{cases}
    0   & x \ge 0 \\
    x^2 & x < 0\\
  \end{cases}
\end{equation}

Furthermore, letting \(x = \eta_i - \nu_{\Xi_i} \kappa_{\Xi_i}\), where \(\nu_{\Xi_i} \kappa_{\Xi_i}\) is the minimum charge threshold, applies a penalty
proportional to the difference of the SOC and the threshold squared.

\begin{figure}[htpb]
  \centering \includegraphics{img/overlap}
  \caption{Examples of different methods of overlapping. Space overlap: $q_{k_1} > q_{i} + 1 \therefore \psi_{ik_{1}} = 1$.
    Time overlap $u_{k_2} < u_{j} + s_j \therefore \sigma_{k_{2}j} = 0$. Similarly, $\sigma_{k_3 i} = 0$.}
  \label{fig:overlap}
\end{figure}

Using the form of \ref{eq:penalty} with and added scalar, \(D\), is employed so that the cost of deviating from the threshold
heavily influences the outcome of the objective function. Therefore, the penalty method is written as

\begin{equation}
\label{eq:penalty-method}
\sum_{i=1}^{n_V} D \phi_i(\eta_i - \nu_{\Xi_i} \kappa_{\Xi_i})\text{.}
\end{equation}

\subsubsection{Consumption Cost}
\label{sec:consumpction-cost}
In most cases, energy companies rely on a volumetric rate as a method of track customer electricity consumption (i.e.
total electricity consumed over a billing period). As such, a method of reducing the total energy consumed by the system
is desired. The energy total energy consumed by a charge schedule is defied by what is known as the consumption cost.
The consumption cost is the summation of all the energy being used over all the active periods for each charger in the
time horizon. This is represented by the summation

\begin{equation}
\label{eq:consumption-cost}
\sum_{i=1}^{n_V} r_{q_i}s_i\text{.}
\end{equation}

That is, the charge rate, \(r_{q_i}\), for the active charger, \(q_i\), is multiplied by the time that the charger will be
utilized, \(s_i\).

\subsubsection{Demand Cost}
\label{sec:demand-cost}
Historically for large industrial customers, energy companies often further rely on a demand cost in conjunction with a
consumption cost for billing. The consumption cost is an important metric as it measures how much power a customer may
require over billing period. Energy companies, having to potentially meet large peaks in demand, offset that cost to the
customer. Thus, when a demand and consumption costs are imposed, not only is the total energy reduction desirable, but
also how much power is consumed at a given moment.

A method of calculating the demand charge is done by calculating the average power consumption over a given period of
time. Let the average power used over an arbitrary interval, \(T_p\), be represented by

\begin{equation}
\label{eq:p}
p_{T_p}(t) = \frac{1}{T_p} \int_{t-T_p}^{t} p(\tau) d\tau\text{.}
\end{equation}

Energy companies take the largest peak when calculating the demand cost. Therefore, let the cost of the peak power
consumption be dictated by the maximum average power:

\begin{equation}
\label{eq:pmax}
p_{max}(t) = \max\limits_{\tau \in [0,t]}p_{T_p}(\tau)\text{.}
\end{equation}

Furthermore, a fixed minimum average power is introduced that is intended to act as a base threshold before the cost
begins to increase. Let this fixed threshold be defined as \(p_{fix}\), the demand cost is calculated using

\begin{equation}
\label{eq:pdem}
p_d(t) = \max(p_{fix},p_{max}(t))\text{.}
\end{equation}

Hence, \ref{eq:pdem} defines a cost beginning with a value of \(p_{fix}\) from which it may only increase if \(p_{15}(t) >
p_{fix}\).

Although the charge times for each BEB is continuous, due to the discrete nature of visits it is simpler to determine a
vector of discrete power consumption over the time horizon from which the average power demand cost may be derived. To
discritize \(p_d\), let \(h \in \{ 1, 2, ..., n_H \} \subset \mathcal{Z}\) where \(n_H\) is the total number of steps. Furthermore, let \(p\)
define the vector of discrete power consumption over some time interval and let \(p_h \in p\) be the discrete power demand
at time step \(h\). For conciseness of notation \(t_h\) will be abused to denote the time in discrete form (as opposed to
\(t\) being continuous), let \(dt_h = t_h - t_{h-1}\), and \(\Hset = \{ 1, 2, ..., n_H \}\). Thus, for a given visit \(i\), the
corresponding discrete indices of \(h \in \Hset\) for the range \([u_i, d_i]\) can be determined by first calculating the
total number of steps, \(n_h = \frac{d_i - u_i}{dt}\). Once the number of steps is known, the consumed power, \(r_{vi}\) can
be added to the correct indices in \(p\).

To derive \(p\), a vector of discrete power consumption over the time horizon, utilizing scheduled visits is outlined in
\ref{alg:calc-p}. In other words, the objective of \ref{alg:calc-p} to calculate a vector, \(p\), that defines the power
consumed over discrete steps throughout time horizon. Line 2 defines the time over which the average power will be
calculated. Line 3 initializes a vector, \(p\), with \(n_H\) elements populated with zeros. The vector \(p\) is used to store
the power consumption for each discrete step over the time horizon \(\T\). Line 5 calculates the number of elements in the
charge time \(s_i\). Line 6 calculates the index of \(p\) for all \(n_h\) steps and iterates through each index. Line 7 adds
the power consumed by charging \(q_i\) for the \(h^{\text{th}}\) step.

\begin{algorithm}[H]
  \scriptsize
  \caption{Calculate vector of power cosumption, $p$, by discretizing a charge time frame, $[u_i, d_i]$, into $n_h$ steps and calculating the appropriate index $h \in \{1,2,...,n_H\}$.} \label{alg:calc-p}
  \LinesNumbered
  \TitleOfAlgo{Calculate $p$}
  \KwIn{$(\I, r)$}
  \KwOut{$p$}

  \Begin
    {
      $dt \leftarrow \frac{\T}{n_H}$\tcc*{Calculate the step size}
      $p \leftarrow [0.0; n_H]$\tcc*{Allocate an $n_H \times 1$ vector filled with zeros}

      \tcc{For each visit}
      \ForEach {$\I_i \in \I$}
      {
        $n_h \leftarrow \frac{\I_{i.d} - \I_{i.u}}{dt}$\tcc*{Calculate the total number of steps in the time slice}

        \tcc{For each index in the time slice $[u_i, d_i]$}
        \ForEach {$h \in \{\frac{u_i}{dt}, \frac{u_i + dt}{dt}, ..., \frac{u_i + n_h dt}{dt}\}$}
        {
          $p[h] \leftarrow p[h] + r_{\I_{i.q}}$\tcc*{Add the consumed power during discrete step}
        }
      }
      \Return{$p$}
    }
\end{algorithm}

With the consumed power calculated for each time step, the average power consumption for each interval in the time
horizon can be written as follows:

\begin{equation}
p_{T_p}[h] = \frac{1}{T_p} \sum_{h-\frac{T_p}{dt}+1}^h p_h,
\end{equation}

where \(T_p \le h \le n_H\). Similarly to before, the maximum \(p_{T_p}[h]\) value is to be retained via \(p_{max} =
\max\limits_{h \in H}p_{T_p}[h]\). Thus, the discrete demand cost is expressed as

\begin{equation}
\label{eq:pd-dis}
  p_d = \max(p_{fix}, p_{max})z\text{.}
\end{equation}

To conclude this section, the objective function is to written in its entirety:

\begin{equation}
\label{eq:objective-function}
  J(\I) = p_d + \sum_{i=1}^{n_V} \epsilon_{q_i}r_{q_i} + D \phi_i(\eta_i - \nu_{\Xi_i} \kappa_{\Xi_i}) + r_{q_i}s_i\text{.}
\end{equation}

\subsection{Constraints}
\label{sec:constraints}
Now that a method of calculating the fitness of a schedule has been established, a method for determining the
feasibility of a schedule must be defined. The feasible space for schedules defines the space in which the input and
decision variables describe a schedule that assign BEBs in such a way that there are no spatiotemporal overlaps and
ensures the BEBs are adequately charged throughout the working day while maintaining their route schedules. To ensure
the selected decision variables fall within the feasible space, a set of constraints are applied to a given candidate
solution. The constraints must ensure no overlap temporally or spatially, the BEB must receive enough charge to complete
its next route, the BEB cannot be over-charged, and the BEB must depart on time. The aforementioned constraints are
shown in the following:

\begin{multicols}{2}
\begin{subequations}
\label{eq:constraints}

  \begin{equation}
      \label{seq:c0}
      u_j - d_i - (\sigma_{ij} - 1)T \ge 0
  \end{equation}
  \begin{equation}
      \label{seq:c1}
      q_j - q_i - 1 - (\psi_{ij} - 1)Q \ge 0
  \end{equation}
  \begin{equation}
      \label{seq:c2}
      \sigma_{ij} + \sigma_{ji} \le 1
  \end{equation}
  \begin{equation}
     \label{seq:c3}
      \psi_{ij} + \psi_{ji} \le 1
  \end{equation}
  \begin{equation}
      \label{seq:c4}
      \sigma_{ij} + \sigma_{ji} + \psi_{ij} + \psi_{ji} \ge 1
  \end{equation}
  \begin{equation}
      \label{seq:c5}
      s_i = d_i - u_i
  \end{equation}
  \begin{equation}
      \label{seq:c6}
       \eta_{\xi_i} = \eta_{i} + r_{q_i}s_i - \Delta_i
  \end{equation}
  \begin{equation}
      \label{seq:c7}
      \kappa_{\Xi_i} \geq \eta_{i} + r_{q_i}s_i
  \end{equation}
  \begin{equation}
      \label{seq:c8}
      a_i \leq u_i \leq d_i \le e_i \le \T
  \end{equation}
\end{subequations}
\end{multicols}

Constraints \ref{seq:c0}-\ref{seq:c4} are the ``queuing constraints''. They are preventing overlap both spatially and
temporally as shown in \ref{fig:overlap}. The y-axis represents the possible queues for a bus visit to be placed into,
and the x-axis represents the time that can be reserved for each visit. The shaded rectangles represent time that has
been scheduled in the horizontal direction, and the queue allocated for each bus visit in the vertical direction. In
other words, the set of constraints \ref{seq:c0} - \ref{seq:c4} aim to ensure that these shaded rectangles never
overlap.

Constraint \ref{seq:c4} states that the starting service time for BEB \(u_j\) must begin after the previous BEB departs,
\(d_i\). The last term utilizes big-M notation to activate or deactivate the constraint. A value of \(\sigma_{ij} = 1\) will
activate the constraint to indicate that bus \(i\) is complete before bus \(j\) is allowed to begin being serviced. If
\(\sigma_{ij} = 0\), then the constraint is of the form \(\T + d_i > u_j\) rendering the constraint ``inactive'' because \(u_j\)
cannot be larger than \(\T + d_i\). This effectively allows the charging windows of the vehicle to overlap. This is
important when the BEBs are not in the same queue.

Similarly, \(\psi_{ij}\) determines whether the vehicles are charging in the same queue. If \(\psi_{ij} = 1\) then \eqref{seq:c1}
is active; thus, vehicle \(i\) is in a queue index that is less than BEB \(j\). If \(\psi_{ij} = 0\) then the constraint is
deactivated and BEB \(i\) is in a queue index greater than that of BEB \(j\).

 \ref{seq:c5} describes the service time of the bus. \ref{seq:c6} calculates the initial charge for the next visit for
bus \(b_i\). \ref{seq:c7} ensures that the bus is not being over-charged. \ref{seq:c8} ensures the continuity of the times
(i.e. the arrival time is less than the initial charge which is less than the detach time which is less than the time
the bus exits the station and all must be less than the time horizon).
\section{Simulated Annealing}
\label{sec:simulated-annealing}
SA is a well-studied local search metaheuristic used to solve discrete and (to a lesser degree) continuous problem
\cite{gendreau-2018-handb-metah,press-1992-numer-recip}. A metaheuristic is a high-level problem-independent algorithm
framework that provides a set of guidelines or strategies to develop heuristic optimization algorithms
\cite{radosavljevic-2018-metah-optim}. Metaheuristic problems primarily fit in two categories: population-based and
single-solution-based. Population based algorithms emphasize exploration of the solution space as apposed to
single-solutions-based algorithms being more exploitation oriented \cite{radosavljevic-2018-metah-optim}. Generally,
metaheuristic algorithms share the basic advantage of speed in finding a satisfactory solution for large-scale practical
optimization problems \cite{radosavljevic-2018-metah-optim}. SA, however, is sometimes criticized for the speed at
which it converges to the global optimum \cite{gendreau-2018-handb-metah,henderson-1989-theor-pract}.

SA is an exploitation oriented, single-solution based metaheuristic. In addition to the advantages of simplicity, both
theoretically and in its implementation, the algorithm has an inherent ability to overcome non-linearities
\cite{gendreau-2018-handb-metah,radosavljevic-2018-metah-optim}. This model is named after its analogized process
where a crystalline solid is heated then allowed to cool at a slow rate until it achieves its most regular possible
crystal lattice configuration \cite{henderson-1989-theor-pract,press-1992-numer-recip}. SA establishes a connection
between this thermodynamic process and the search for global optima in optimization problems.

There are five key components to SA: initial temperature, cooling schedule (temperature function), generation
mechanisms, acceptance criteria, and a constant temperature iteration count (temperature change counter)
\cite{keller-2019-multi-objec,press-1992-numer-recip}. The temperature function describes the speed at which the
system is ``cooled'' over each iteration. The generation mechanisms provide a means of modifying the system by some
singular discrete change that is within the neighborhood of the previous solution \cite{gendreau-2018-handb-metah}. The
acceptance criteria is a function of the system temperature that makes the decision whether the system will accept an
inferior solution in favor of exploring the solution space. Finally, the constant temperature iteration count is the
number of steps taken to try to exploit a solution at a constant temperature. Each of these mechanisms are elaborated in
the subsequent sections.

\subsection{Cooling Equation}
\label{cooling-equation-experimental}
The temperature function models a ``rate of cooling'' for the SA process. Initially, when the temperature is high, SA
encourages exploration. As the process begins to ``cools down'' (in accordance to the cooling schedule), it begins to
encourage local exploitation of the solution (rather than exploration)
\cite{rutenbar-1989-simul-anneal-algor,henderson-1989-theor-pract}. There are three common basic types of cooling
equations: linear, geometric, and exponential. Each schedule type is depicted in \ref{fig:cool}
\cite{keller-2019-multi-objec}. Every plot begins with an initial temperature of \(T_0 = 500^\circ\; C\) and a final
temperature of \(T_f = 1^\circ\; C\). The different cooling schedules dictate the rate at which the algorithm progressively
disallows exploration. Let the vector of temperatures described by a cooling schedule be defined as \(t\). Furthermore,
let an element of the vector be denoted as \(t_m \in t\), where \(m \in [0,...,M]\) and \(M = \lvert t \rvert\).

A linear cooling schedule is defined by \(t_m = t_{m-1} - \beta_0\). The terms utilized in \ref{fig:cool} are \(t_0 = \Tau_0\)
and \(\beta_0 = 1/2\; C^\circ\). An exponential cooling schedule is defined by the difference equation \(t_m = e^{-\beta_2}t_{m-1}\).
The values utilized in \ref{fig:cool} are \(\beta_2 = 0.01\). A geometric cooling schedules is as defined in \ref{eq:cool}. This
schedule type is most widely used in practice \cite{keller-2019-multi-objec}. As such, it will also be employed by this
work.

\begin{equation}
\label{eq:cool}
t_m = \beta_1 t_{m-1}
\end{equation}

The gain variable, \(\beta_1\), in \ref{fig:cool} evaluated at \(\beta_1 = 0.995\). The value of \(\beta_1\) may vary anywhere between the
range \([0,1)\). The further \(\beta_1\) is from 1, the quicker the function converges to zero. \ref{fig:geometric} demonstrates
this principle by plotting the geometric schedule using varying values of \(\beta_1\).

\begin{figure}[t!]
  \begin{subfigure}[t]{0.5\textwidth}
    \centering \includegraphics[width=\textwidth]{img/cool_func.png}
    \caption{Geometric, linear, and exponential cooling schedules.}
    \label{fig:cool}
  \end{subfigure}
  ~
  \begin{subfigure}[t]{0.5\textwidth}
    \centering \includegraphics[width=\textwidth]{img/geometric.png}
    \caption{Geometric cooling schedule utilizing various value of $\beta_1$.}
    \label{fig:geometric}
  \end{subfigure}
\end{figure}

\subsection{Acceptance Criteria}
\label{sec:acceptance}
In SA, the algorithm stores a candidate solution that is continuously compared to newly generated solutions. Let the
stored solution be referred to as the ``active solution''. During each iteration, a new candidate solution is generated
and compared to the active solution to determine if the new solution should replace the active solution. In order to
determine if the active solution is to be replaced, an acceptance criteria is defined. A new candidate solution that is
more fit than active solution (fitness being dictated by the objective function) is always accepted as the new active
solution. In an effort to encourage exploration, inferior candidate solutions have a probability of being accepted as
the active solution. The probability of accepting an inferior candidate solution is described by the function
\(\exp(-\frac{J(\I) - J(\bar{\I})}{t_m})\) where \(J(\cdot)\) is the objective functions described in \ref{sec:objective-function},
\(t_m\) is current temperature, \(\I\) is the current solution, and \(\bar{\I}\) is the new candidate solution. The
probability of acceptance is a function of the current temperature and the difference of the active solution and a new
candidate solution. Formally, let \(\Delta E \equiv J(\I) - J(\bar{\I})\) and let \(f(\cdot)\) be the function that describes the
probability of accepting a candidate solution \(\bar{\I}\). The probability of accepting a candidate solution is thus of
the form \cite{keller-2019-multi-objec}

\begin{equation}
\label{eq:candaccept}
f(x,\bar{x},t_m) =
\begin{cases}
  1                   & \Delta E > 0 \\
  e^{- \frac{\Delta E}{t_m}} & \text{otherwise}
\end{cases}\text{.}
\end{equation}

\subsection{Generation Mechanisms}
\label{sec:generation-mechanisms}
Generation mechanisms are used to create a neighboring candidate solution \cite{gendreau-2018-handb-metah}. That is,
the generating function creates a solution that can be reached in a single iteration from the active solution. In the
case of the problem statement made in \ref{sec:problem-description}, five primitive generation mechanism shall be used: new
visit, slide visit, new charger, new window, wait. The purpose of each of these generators is to assign new visits to a
charger, adjust a bus visits initial and final charge time within the same time frame/queue, move a BEB from one charger
to another with the same charge schedule, move a bus to its idle queue. A helper function, purge, is also introduced.
This function simply removes a charger from the set available charge times. Each generator will be discussed in more
detail in \ref{sec:generators}.

These generation mechanisms will in turn be utilized by two wrapper functions. The schedule generation is to used create
an initial candidate solutions for SA and the perturb schedule generator is used to take a candidate solution and alter
it slightly in an attempt to step toward a global or local minimum. The wrapper functions will be discussed in
\ref{sec:generator-wrappers}. However, prior to discussing the primitives and wrapper generating functions, their respective
inputs and outputs must be defined.

\subsubsection{Generator Input/Output}
\label{sec:generator-input-output}
This section discusses in detail the expected inputs and outputs of each generator. The input consists of the bus visit
index of interest, the current state of visits, \(\I\), and the current state of the charger availability, \(\C\). The
output of each generator affects a subset \(\I\) and the charger availability \(\C\).

In the development of the algorithms, dot notation is to be introduced to extract variables from tuples. For example,
suppose the arrival time is desired to be extracted from visit \(i\). Given \(\I\), the notation that describes extracting
the initial charge time, \(u_i\), for visit \(i\) is written as \(u_i \equiv \I_{i.u}\).

\paragraph{Generator Input}
\label{sec:orgc865257}
Each generator accepts an input of the tuple of the form \(\Sol \equiv (i, \I, \C)\) where \(i\) is the visit index being
manipulated, \(\I\) is the set of visits, and \(\C\) is the set that describes the availability for all chargers \(q \in
\Qset\).

\paragraph{Generator Output}
\label{sec:orgfb13800}
The output of the generating functions is the same as the input, \(\Sol\), but with changes applied to it by a generator.
Let a modified variable be denoted with a bar, \(\bar{\cdot}\). Thus, the modified input tuple is written as \(\bar{\Sol}\).
Although not all the variables in \(\Sol\) are modified, it is written in this manner for the sake of consistency and
simplicity in bookkeeping.

\subsubsection{Generators}
\label{sec:generators}
This section describes and outlines the algorithm pool for the different generator types that are utilized in the
wrapper functions. Recall that to satisfy constraints, \(n_B\) extra idle queues are added that provide no power to the
BEB. Because of this, the set of queues is fully defined as \(q \in \{1,..., n_B, n_B+1,..., n_Q+n_B\}\) where \(n_Q\) is the
total amount of chargers and \(n_B\) number of BEBs. The use case for the idle queues are for when a bus is not to be
placed on a charger. Rather, it will be placed in the queue, \(q \in B\), which satisfies the previously defined spatial
constraints while allowing the bus to be ``set aside''.

\paragraph{New visit}
\label{sec:new-visit}
The new visit generator defined in \ref{alg:new-visit} describes the process of moving a BEB, \(b \in B\), from a waiting
queue, \(q \in B\), to a charging queue, \(q_i \in \{n_B+1,..., n_B + n_Q\}\), within its arrival/departure time \([a, e]\). Let
\(\U_{\{\cdot\}}\) indicate that an element is selected randomly with a uniform distribution from the set \(\{\cdot\}\). For
example, \(\U_{[a, e]}\) indicates that a value will be selected between \(a\) and \(e\) with a uniform distribution. Line 2
extracts the index of the visit. Lines 3 through 4 of extract the arrival and departure times of visit \(i\). Line 5
retrieves the currently assigned charge queue. Lines 6 and 7 select a charging queue, \(q\), and time slice for which \(q\)
is available at random with uniform distributions, respectively. Line 8 verifies that the inactive period selected is
viable and returns a random charging time, \([u, d]\). If the time frames of the visit and the charger availability do not
align, the null value is returned.

The function \texttt{findFreeTime} is the algorithm that determines whether a visit's time at the station \([a, e]\) can be placed
in the time availability of charger \(q\). Let the available time for charger \(q\) for visit \(i\) be denoted as \(C \equiv
\C_{i.q}\). The algorithm is defined in \ref{alg:find-free-time}. Let \(C_L\) and \(C_U\) be the lower and upper bound of the
time between active times for charger \(q\). The set of cases in which the ranges \([a, e]\) and \([C_L, C_U]\) may interact
is shown in \ref{fig:find-free}. In each case depicted by \ref{fig:find-free}, the red lines depict the arrival and departure time
for a BEB visit, \(i\). The blue lines indicate regions in which charger \(q\) is active. \(C \in \C_q\) represents one of the
ranges between the blue lines, \([C_L, C_U]\).

The \texttt{findFreeTime} algorithm is outlined in \ref{alg:find-free-time} and behaves as follows. Lines 2 and 3 extract the
lower and upper bounds of the charger availability. Lines 4 - 23 check whether the BEB visit can be assigned to the
charger available time slice. Lines 4 - 7 relate to the scenario in \ref{subfig:sandwich}. That is, the BEB visit fits
entirely within the charger availability and the charge time may be anywhere in the range \([a, e]\). Lines 8 - 11
coincides with \ref{subfig:all} where the BEB arrives before the charger is available. Therefore, the BEB may charge
anywhere in the time \([L, e]\). On the opposite end, Lines 12 - 15 represents the scenario in \ref{subfig:egu} in which
the BEB departs after the upper bound of the charger availability. Thus, the BEB may be charged anywhere in the time
frame of \([a, U]\). Lines 16 - 19 corresponds to the scenario in \ref{subfig:invertsandwhich} where the upper and lower
bound of the visit is constrained by the charger availability such that the time that the BEB can charge is between the
time slice \([L,U]\). Lines 20-24 relate to the scenarios in which the BEB visit does not fall within the charger
availability and assigns the null value to both \(\bar{u}\) and \(\bar{d}\). Lines 24-28 check if a time range has been
assigned. If one has, the time slice \([\bar{u}, \bar{d}]\) is assigned to the compliment of the charger availability.
Line 26 returns tuple of the updated charger availability and the initial and final charging times. Line 29 returns the
original charger availability and null values for the charge times upon failure.

\begin{algorithm}[H]
  \scriptsize
  \caption{New visit algorithm}
  \label{alg:new-visit}
  \LinesNumbered
  \TitleOfAlgo{New Visit}
  \KwIn{$\Sol$}
  \KwOut{$\bar{\Sol}$}

  \SetKwFunction{Union}{Union}
  \SetKwFunction{findFreeTime}{findFreeTime}

  \Begin
    {
      $i \leftarrow \Sol_{i}$\tcc*{Extract visit index}
      $a \leftarrow \I_{i.a}$\tcc*{Extract the arrivial time for visit $i$}
      $e \leftarrow \I_{i.e}$\tcc*{Extract the departure time for visit $i$}
      $q \leftarrow \I_{i.q}$\tcc*{Extract the current charge queue for visit $i$}
      $\bar{q} \leftarrow \mathcal{U}_{Q}$\tcc*{Select a random charging queue with a uniform distribution}
      $C \leftarrow \mathcal{U}_{\C_q}$\tcc*{Select a random time slice from $\C_q$}

      \If(\tcc*[f]{If there is time available in $C_q^j$}){($\bar{C}, \bar{u}, \bar{d}$) $\leftarrow$ \findFreeTime{$C, i, q, a, e$} $\not\in \varnothing$}
         {
           \Return{($i, (\bar{q},\bar{u},\bar{d}),\bar{C}$)}\tcc*[f]{Return visit}
         }

         \Return{($\varnothing$)}\tcc*{Return nothing}
    }
\end{algorithm}

\begin{figure}[!h]
\centering
\begin{subfigure}{\textwidth}
    \centering
    \caption{Valid position: $a \leq u \leq d \leq e$}
    \label{subfig:sandwich}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (0,0);
        \coordinate (B) at (1.5,0);
        \coordinate (C) at (2.0,0);
        \coordinate (D) at (3.5,0);
        \coordinate (E) at (4.0,0);
        \coordinate (F) at (5.5,0);

        \draw[blue] (A) -- (B);
        \draw[red]  (C) -- (D);
        \draw[blue] (E) -- (F);

        \node[circle,fill=blue,radius=0.15]                     at (A) {};
        \node[circle,fill=blue,radius=0.15,label=above : $C_L$] at (B) {};
        \node[circle,fill=red,radius=0.15,label=above  : $a$]   at (C) {};
        \node[circle,fill=red,radius=0.15,label=above  : $e$]   at (D) {};
        \node[circle,fill=blue,radius=0.15,label=above : $C_U$] at (E) {};
        \node[circle,fill=blue,radius=0.15]                     at (F) {};
    \end{tikzpicture}
\end{subfigure}

\par\bigskip

\begin{subfigure}{\textwidth}
    \centering
    \caption{Valid position: $C_L \leq u \leq d \leq e$}
    \label{subfig:all}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (0,0);
        \coordinate (B) at (2.5,0);
        \coordinate (C) at (2.0,0);
        \coordinate (D) at (3.5,0);
        \coordinate (E) at (4.0,0);
        \coordinate (F) at (5.5,0);

        \draw[blue] (A) -- (B);
        \draw[red]  (C) -- (D);
        \draw[blue] (E) -- (F);

        \node[circle,fill=blue,radius=0.15]                     at (A) {};
        \node[circle,fill=blue,radius=0.15,label=above : $C_L$] at (B) {};
        \node[circle,fill=red,radius=0.15,label=above  : $a$]   at (C) {};
        \node[circle,fill=red,radius=0.15,label=above  : $e$]   at (D) {};
        \node[circle,fill=blue,radius=0.15,label=above : $C_U$] at (E) {};
        \node[circle,fill=blue,radius=0.15]                     at (F) {};
    \end{tikzpicture}
\end{subfigure}

\par\bigskip

\begin{subfigure}{\textwidth}
    \centering
    \caption{Valid position: $a \leq u \le d \leq C_U$}
    \label{subfig:egu}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (0,0);
        \coordinate (B) at (1.5,0);
        \coordinate (C) at (2.0,0);
        \coordinate (D) at (3.5,0);
        \coordinate (E) at (3.0,0);
        \coordinate (F) at (5.5,0);

        \draw[blue] (A) -- (B);
        \draw[red]  (C) -- (D);
        \draw[blue] (E) -- (F);

        \node[circle,fill=blue,radius=0.15]                     at (A) {};
        \node[circle,fill=blue,radius=0.15,label=above : $C_L$] at (B) {};
        \node[circle,fill=red,radius=0.15,label=above  : $a$]   at (C) {};
        \node[circle,fill=red,radius=0.15,label=above  : $e$]   at (D) {};
        \node[circle,fill=blue,radius=0.15,label=above : $C_U$] at (E) {};
        \node[circle,fill=blue,radius=0.15]                     at (F) {};
    \end{tikzpicture}
\end{subfigure}

\par\bigskip

\begin{subfigure}{\textwidth}
    \centering
    \caption{Valid position: $C_L \le u \leq d \leq C_U$}
    \label{subfig:invertsandwhich}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (0,0);
        \coordinate (B) at (1.5,0);
        \coordinate (C) at (2.0,0);
        \coordinate (D) at (3.5,0);
        \coordinate (E) at (4.0,0);
        \coordinate (F) at (5.5,0);

        \draw[blue] (A) -- (C);
        \draw[blue] (D) -- (F);
        \draw[red]  (B) -- (E);

        \node[circle,fill=blue,radius=0.15]                    at (A) {};
        \node[circle,fill=red,radius=0.15,label=above : $a$]   at (B) {};
        \node[circle,fill=blue,radius=0.15,label=above: $C_L$] at (C) {};
        \node[circle,fill=blue,radius=0.15,label=above: $C_U$] at (D) {};
        \node[circle,fill=red,radius=0.15,label=above : $e$]   at (E) {};
        \node[circle,fill=blue,radius=0.15]                    at (F) {};
    \end{tikzpicture}
\end{subfigure}

\par\bigskip

\begin{subfigure}{\textwidth}
    \centering
    \caption{Invalid position upper bound}
    \label{subfig:invalid-upper}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (0.0,0);
        \coordinate (B) at (5.5,0);
        \coordinate (C) at (1.5,0);
        \coordinate (D) at (3.5,0);

        \draw[-{Latex[width=3mm]},blue]  (A) -- (B);
        \draw[red]  (C) -- (D);

        \node[circle,fill=blue,radius=0.15,label=above : $C_U$] at (A) {};
        \node[circle,fill=red,radius=0.15,label=above  : $a$] at (C) {};
        \node[circle,fill=red,radius=0.15,label=above  : $e$] at (D) {};
    \end{tikzpicture}
\end{subfigure}

\par\bigskip

\begin{subfigure}{\textwidth}
    \centering
    \caption{Invalid position lower bound}
    \label{subfig:invalid-lower}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (0.0,0);
        \coordinate (B) at (5.5,0);
        \coordinate (C) at (1.5,0);
        \coordinate (D) at (3.5,0);

        \draw[-{Latex[width=3mm]},blue]  (B) -- (A);
        \draw[red]  (C) -- (D);

        \node[circle,fill=blue,radius=0.15,label=above : $C_L$] at (B) {};
        \node[circle,fill=red,radius=0.15,label=above  : $a$] at (C) {};
        \node[circle,fill=red,radius=0.15,label=above  : $e$] at (D) {};
    \end{tikzpicture}
\end{subfigure}

\caption{This figure depicts the different states in which a charger with an availability time frame, $[C_L,C_U]$, can be placed on a timeline relative to a visit's total time at the station. The blue lines indicate ranges where the charger is being uilized. The point $C_L$ is the lower bound of the available time and $C_U$ is the upper bound. The red lines, $\bar{ae}$, indicate the time slice in which visit $i$ is at the station. Thus, the BEB may be assigned a charge time anywhere in the range between $C_L$ and $C_U$. For example, \ref{subfig:sandwich} allows the BEB to be charged anywhere in the time range $[a, e]$. \ref{subfig:all} allows a BEB to charge in the time frame $[C_L,e]$. \ref{subfig:egu} allows a BEB to charge in the time frame $[a,C_U]$. \ref{subfig:invertsandwhich} allows charging during the time frame $[C_L,C_U]$. The last two permutations, \ref{subfig:invalid-upper} and \ref{subfig:invalid-lower}, do not allow the BEB to be assigned.}
\label{fig:find-free}
\end{figure}
\begin{algorithm}[H]
\scriptsize
\caption{Find free time algorithm checks whether the BEB time at the station, $[a_i, e_i]$ fits within the charger availability $[L,C_U]$. If it does, a random charge time slice is returned, otherwise the null value is returned.}
\label{alg:find-free-time}
    \LinesNumbered
    \TitleOfAlgo{Find Free Time}
    \KwIn{$(\C, i, q, a, e)$}
    \KwOut{($\bar{\C}, \bar{u}, \bar{d})$}

    \Begin
    { \tcc{Extract the lower and upper bounds.}
      $C_L \leftarrow \C_{i.q}$\;
      $C_U \leftarrow \C_{i.q}$\;

      \If(\tcc*[f]{If $C_L \le a \le e \le C_U$ (\autoref{subfig:sandwich})}){$C_L \leq a$ and $C_U \geq e$}
      {
        $\bar{u}\leftarrow$ $\U_{[a,e]}$\;
        $\bar{d}\leftarrow$ $\U_{[\bar{u},e]}$\;
      }
      \ElseIf(\tcc*[f]{Else if $a \le C_L \le e < C_U$ (\autoref{subfig:all})}){$C_L \ge a$ and $C_U \geq e$}
      {
        $\bar{u}\leftarrow$ $\U_{[C_L,e]}$\;
        $\bar{d}\leftarrow$ $\U_{[\bar{u},e]}$\;
      }
      \ElseIf(\tcc*[f]{Else if $C_L \le a \le C_U < e$ (\autoref{subfig:egu})}){$C_L \leq a$ and $C_U \le e$}
      {
        $\bar{u}\leftarrow$ $\U_{[a,C_U]}$\;
        $\bar{d}\leftarrow$ $\U_{[\bar{u},C_U]}$\;
      }
      \ElseIf(\tcc*[f]{Else if $a \leq C_L \leq C_D \leq u$ (\autoref{subfig:invertsandwhich})}){$C_L \ge a$ and $C_U \le e$}
      {
        $\bar{u}\leftarrow$ $\U_{[C_L,C_U]}$\;
        $\bar{d}\leftarrow$ $\U_{[\bar{u},C_U]}$\;
      }
      \Else(\tcc*[f]{Otherwise the bus cannot be scheduled in this time frame (\autoref{subfig:invalid-lower}, \autoref{subfig:invalid-upper})})
      {
        $\bar{u}\leftarrow$ $\varnothing$\;
        $\bar{d}\leftarrow$ $\varnothing$\;
      }

      \If (\tcc*[f]{If an assignment was made}) {$\bar{u},\bar{d} \ne \varnothing$}
      {
        $\bar{\C}_q' \leftarrow \C_q' \cup \{[\bar{u},\bar{d}]\}$\tcc*{Update the compliment of the charger free time slices}
        \Return{($\bar{C},\bar{u},\bar{d}$)}
      }
      \Else(\tcc*[f]{Otherwise the assignment failed})
      {
        \Return{($C,\varnothing, \varnothing$)}
      }
    }
\end{algorithm}

\paragraph{Purge}
\label{sec:purge}
The purge procedure simply removes a assigned charge time from the set \(\C\). This function, while not a generator,
exists so that other primitives may place the visit back into the schedule without creating duplicate entries in \(\C\).
Line 2 from \ref{alg:purge} updates \(\C\) with the set of visits excluding visit \(i\) from charging queue \(q_i\). Line 3
returns the updated set of charger availability.

\begin{algorithm}[H]
  \scriptsize
  \caption{Purge algorithm} \label{alg:purge}
    \LinesNumbered
    \TitleOfAlgo{Purge}
    \KwIn{$\Sol$}
    \KwOut{$\bar{\Sol}$}

    \Begin
    {
      $\bar{\C} \leftarrow \C \setminus \C_{i.q_i}$\tcc*{Remove assignment of visit $i$ to charger $q_i$}
      \Return{$(i, \I, \bar{\C})$}\tcc*{Return updated tuple}
    }
  \end{algorithm}

\paragraph{Slide visit}
\label{slide-visit}
This primitive generator is used for buses that have already been scheduled. Because of the constraint \ref{seq:c8}
there may be some slack to manipulate \([u_i, d_i]\) within the window \([a_i, e_i]\). That is, two new values, \(u_i\) and
\(d_i\) are randomly selected with a uniform distribution that satisfy the constraint \(a_i \leq u_i \leq d_i \leq e_i\). Line 2 from
\ref{alg:slide-visit} purges the visit from the charger availability schedule. Line 4 retrieves the window that was
opened up by purging visit \(i\). Line 4 sets the new charge time frame, \([u_i, d_i]\). Line 5 returns the updated visit
information. If \texttt{findFreeTime} was unsuccessful, then the generator returns a tuple of null values.

\begin{algorithm}[H]
  \scriptsize
  \caption{Slide Visit Algorithm} \label{alg:slide-visit}
  \LinesNumbered
  \TitleOfAlgo{Slide Visit}
  \KwIn{$\Sol$}
  \KwOut{$\bar{\Sol}$}

    \SetKwFunction{Purge}{Purge}

    \Begin
    {
      $(i, \I, \bar{\C}) \leftarrow$\Purge{$\Sol$}\tcc*{Purge visit $i$ from charger availibility matrix}
      $C \leftarrow \bar{C}_{i.q_i}$\tcc*{Get the time availability of the purged visit}

      \tcc{If there is time available in $C$}
      \If{($\bar{C}, \bar{u}, \bar{d}$) $\leftarrow$ \findFreeTime{$C$, $\Sol_i$, $\I_q$, $\I_{i.a}, \I_{i.e}$} $\not\in \varnothing$}
      {
        \Return{($i, \I, (\I_{i.q_i},\bar{u},\bar{d}),\bar{C}$)}\tcc*[f]{Return updated visit}
      }

        \Return{($\varnothing$)}\tcc*{Return nothing}
    }
  \end{algorithm}

\paragraph{New charger}
\label{new-charger}
The new charger generator moves a visit \(\I_i\) to a new charging queue while maintaining the same charge time, \([u_i,
d_i]\). Line 2 from \ref{alg:new-charger} purges the visit from the charger availability set. Line 3 randomly selects a
charger queue index, \(q\). Line 4 checks if there is an available time slice \([a_i, e_i]\) for charger \(q\). Line 5 returns
the updated visit data. If \texttt{findFreetime} was unsuccessful, then the generator returns a tuple of null values.

\begin{algorithm}[H]
  \scriptsize
  \caption{New Charger Algorithm} \label{alg:new-charger} \LinesNumbered \TitleOfAlgo{New Charger} \KwIn{$\Sol$}
  \KwOut{$\bar{\Sol}$}

    \SetKwFunction{Purge}{Purge}

    \Begin
    {
      $(i, \I, \bar{\C}) \leftarrow$\Purge{$\Sol$}\tcc*{Purge visit $i$ from charger availibility matrix}
      $q \leftarrow \mathcal{U}_{Q}$\tcc*{Select a random charging queue with a uniform distribution}

      \If(\tcc*[f]{If there is time available in $C_{q}$}){($\bar{C}, \bar{u}, \bar{d}$) $\leftarrow$ \findFreeTime{$\bar{\C}_{i.q}$, $\Sol_i$, $\I_q$, $\I_{i.a}, \I_{i.e}$} $\not\in \varnothing$}
      {
        \tcc{Return visit, note $u$ and $d$ are the original inital/final charge times.}
        \Return{($i, \I, (q,\I_{i.u}, \I_{i.d}),\bar{\C}$)}
      }

      \Return{($\varnothing$)}\tcc*{Return nothing}
    }
  \end{algorithm}

\paragraph{Wait}
\label{sec:wait}
The wait generator simply removes a bus from a charger queue and places it in its idle queue, \(q_i \in \{1,...,B\}\).
Line 2 from \ref{alg:wait} purges the visit from the charger availability set. Line 4 updates the complement charger
availability schedule of the wait queue for bus \(b\). Line 5 returns the updated visit.

\begin{algorithm}[H]
\scriptsize
\caption{Wait algorithm} \label{alg:wait}
    \LinesNumbered
    \TitleOfAlgo{Wait}
    \KwIn{$\Sol$}
    \KwOut{$\bar{\Sol}$}

    \SetKwFunction{Purge}{Purge}

    \Begin
    {
      $(i, \I, \bar{\C}) \leftarrow$\Purge{$\Sol$}\tcc*{Purge visit $i$ from charger availibility matrix}
      $\bar{\C}'_{\I_{i.\Gamma_i}} \leftarrow \C' \cup \{[\I_{i.a}, \I_{i.e}]\}$\tcc*{Update the charger availability matrix for wait queue $\bar{\C}_{i.q_i}$}
      \Return{$(i, \I, (\I_{i.b}, \I_{i.a}, \I_{i.e}), \bar{\C})$}\tcc*[f]{Return visit}
    }
  \end{algorithm}

\paragraph{New Window}
\label{sec:new-window}
New window, as shown in \ref{alg:new-window}, is a combination of \ref{alg:new-visit} (new visit) and \ref{alg:wait}
(wait). By this it is meant that visit \(i\) is placed in its wait queue then added back in as if it were a new visit.
This implies that the BEB may be assigned to a different queue and a new charge time slice. Line 2 purges the BEB visit
from the schedule producing \(\bar{\Sol}\). Line 3 places the BEB back into the schedule using the new visit generator,
producing \(\bar{\bar{\Sol}}\). Line 4 assigns and returns the updated visit. Line 6 returns the null visit upon failure
of \ref{alg:new-visit}.

\begin{algorithm}[H]
  \scriptsize
  \caption{New window algorithm} \label{alg:new-window}
  \LinesNumbered
  \TitleOfAlgo{New Window}
  \KwIn{$\Sol$}
  \KwOut{$\bar{\Sol}$}

  \SetKwFunction{NewVisit}{NewVisit}
  \SetKwFunction{Purge}{Purge}

  \Begin
  {
    $\bar{\Sol} \leftarrow$\Purge{$\Sol$}\tcc*{Purge visit $i$ from charger availibility matrix}
    \If(\tcc*[f]{Add visit $i$ back in randomly})
       {
         $\bar{\bar{\Sol}} \leftarrow$ \NewVisit{$\bar{\Sol}$} $\not\in \varnothing$
       }
       {
         \Return{$\bar{\bar{\Sol}}$} \tcc*[f]{Return visit}
       }

       \Return{($\varnothing$)}\tcc*{Return nothing}
  }
\end{algorithm}

\subsubsection{Generator Wrappers}
\label{sec:generator-wrappers}
This section covers the algorithms utilized to select and execute different generation processes. The generator wrappers
are the methods immediately called by the SA algorithm. Each wrapper utilizes the primitive generators previously
described and returns either a new charge schedule or a modified charge schedule.

\paragraph{Charge Schedule Generation}
\label{sec:charge-schedule-generation}
The objective of \ref{alg:charge-schedule-generation} is to assign each BEB to a random charge queue and charge time.
Specifically, this generator exists to initialize the system with a solution in a greedy manner. Line 2 of
\ref{alg:charge-schedule-generation} loops through each visit and Line 4 executes \ref{alg:new-visit} to place visit \(i\)
at random queue with a random charge time.

\begin{algorithm}[H]
\scriptsize
\caption{Charge schedule generation algorithm} \label{alg:charge-schedule-generation}
    \LinesNumbered
    \TitleOfAlgo{Candidate Solution Generator}
    \KwIn{$\Sol$}
    \KwOut{$\bar{\Sol}$}

    \SetKwFunction{NewVisit}{NewVisit}

    \Begin
    {
        \tcc{Select an unscheduled BEB visit from a randomly indexed set of visits}
        \ForEach {$\I_i \in \I$}
        {
            ($i, \bar{\I}$, $\bar{\C}$) $\leftarrow$ \NewVisit{($\I_i$, $\I$, $\C$)}\tcc*{Assign the bus to a charger}
        }
            \Return{($0, \bar{\I}$, $\bar{\C}$)}
    }
  \end{algorithm}

\paragraph{Perturb Schedule}
\label{sec:tweak-schedule}
Once the active solution has been created by \ref{alg:charge-schedule-generation}, the SA process begins modifying it to
create candidate solutions. After each step of the cooling function, the active solution will be altered \(n_K\) times by
a random primitive generator. During these \(n_K\) iterations the active solution is modified to create a neighboring
candidate solution. This candidate solution will then be compared against the active solution in the manner discussed in
\ref{sec:acceptance}. \ref{alg:perturb-schedule} describes the method by which the SA algorithm decides how to perturb the
schedule. The method that will be employed generate a neighboring solution is as follows: pick a visit, pick a primitive
generator, and execute said primitive generator once. Furthermore, the primitives are not desired to be picked at random
with a uniform distribution. That is, a weighted distribution is required. Let \(\W^y_{[\cdot]}\) denote a random selection
with a distribution specified by a weight vector \(y \in \mathbb{R}\). Thus, \ref{alg:perturb-schedule} is as follows: Line 2 selects
a visit at random with a uniform distribution. Line 3 extracts the visit index and Line 4 creates a vector of weights
associated with a primitive generator. Letting \(n_G\) denote the number of primitive generating functions, Line 5 selects
a primitive generator with a weighted distribution. Line 6 executes the primitive, and Line 7 returns the result.

\begin{algorithm}[H]
\scriptsize
\caption{Perturb schedule algorithm} \label{alg:perturb-schedule}

    \LinesNumbered
    \TitleOfAlgo{Perturb Schedule}
    \KwIn{$\Sol$}
    \KwOut{$\bar{\Sol}$}

    \SetKwFunction{PGF}{PGF}

    \Begin
    {
        $\I_i\leftarrow\; \U_{\I}$\tcc*{Randomly select a visit}
        $i \leftarrow\; \I_i$\tcc*{Extract visit index}
        $y \leftarrow [y_1, y_2, ...]$\tcc*{Define the weight of each primitive generator}
        $PGF \leftarrow\; \W^y_{[1,n_G]}$\tcc*{Select one of the generator functions}
        $\bar{\Sol} \leftarrow$ \PGF{($i$, $\I$, $\C$)}\tcc*{Excecute the generator function}
        \Return{($0, \bar{\I}$, $\bar{\C}$)}
    }
\end{algorithm}

\subsection{Alternative Heuristic Implementation}
\label{sec:heuristic-implementation}
As suggested by the works in \cite{Zhang_2010,Xinchao_2011}, applying heuristics to the generating functions can
manipulate the searched neighborhoods in a way that may assist the SA algorithm with convergence. As a test to assist in
minimizing charger utilization, a simple heuristic was applied to \ref{alg:new-visit} and \ref{alg:new-charger} in the
method that they select new charging queues. Suppose rather than selecting a queue at random from \(q \in Q\), the
algorithms randomly select whether to place a BEB in a slow or fast charging queue with a weighted distribution favoring
slow chargers. Once the charger type has been selected, the algorithm will then begin incrementally attempting to place
the BEB in a queue of that type beginning from the smallest index of that charger type. For example, if a BEB has been
selected to be placed in a queue with a slow charger, the algorithm begins by attempting to place the BEB in the charger
queue \(q = n_B + 1\). If it is unable to be placed in that queue, it then attempts to be placed in the next queue \(q =
n_B + 2\). This is done incrementally until all the queues have been exhausted.
\section{Optimization Algorithm}
\label{sec:optimization-algorithm}
This section combines the generation algorithms and the optimization problem into a single algorithm. It begins with an
introduction and discussion of a general SA algorithm which will be used to springboard into the construction of the SA
PAP algorithm.

\subsection{Simulated Annealing Pseudo Code}
\label{sec:simulated-annealing-pseudo-code}
Let \(\omega\) and \(\bar{\omega}\) denote the active solution and the candidate solution, respectively. Let \(\Tau\) be the temperature
function and \(\Tau_0\) the initial temperature. Furthermore, let \(t\) be defined as the vector of temperatures defined by
\(t = \Tau(\Tau_0)\), and let \(t_m\) be defined as being an element of \(t\), \(t_m \in t\). Let \(n_K\) be the repetition counter,
it defines the number of iterations to execute exploit a solution at a constant temperature \(t_m\).

Recall the objective of the SA algorithm is to iteratively create a neighboring candidate solution from the active
solution. The fitness of the two solutions are compared and if the candidate solution is of a higher quality, it is
always taken as the active solution. If it is not, then it may be selected as the new candidate solution with some
probability that is a function of the difference in the objective function values and the current temperature. This
process is iteratively done until the temperature function reaches its minimum value. With the high level summary in
mind, the SA pseudocode is to be presented \cite{henderson-1989-theor-pract}.

The algorithm behaves as follows: Lines 1 and 2 of \ref{alg:sa-pseudo} initialize the SA algorithm the temperature
schedule, \(t\), and active solution, \(\omega\), respectively. The outer loop on Line 3 iterates through all the temperature
values in \(t\). After each iteration of the outer loop, the temperature is decreased as specified by the selected
temperature function. Line 4 resets the iteration counter to 0. Line 5 specifies the inner loop that iterates \(n_K\)
times at a constant temperature, \(t_k\). Line 6, perturbs the active solution \(\omega\) to a neighboring candidate solution
\(\bar{\omega} = N(\omega)\). Line 7 then calculates the difference in the fitness of \(\omega\) and \(\bar{\omega}\). Lines 8-13 updates \(\omega\) with
\(\bar{\omega}\) if the candidate solution is more fit, or updates \(\omega\) with \(\bar{\omega}\) with probability \(e^{\frac{-\Delta_{\omega ,
\bar{\omega}}}{t_m}}\) if the candidate solution is less fit than the active solution. Line 14 updates the repetition counter.

\begin{algorithm}[H]
\scriptsize
\caption{Pseudo-code for SA} \label{alg:sa-pseudo}
\LinesNumbered
\TitleOfAlgo{SA Pseudo-Code}

\SetKwFunction{Obj}{J}
\SetKwFunction{New}{N}
\SetKwFunction{Pert}{P}
\SetKwFunction{Temp}{$\Tau$}

\Begin
  {
        \tcc{Generate vector of temperatures given temperature function $\Tau$ and initial temperature $\Tau_0$}
        $t \leftarrow$ \Temp{$\Tau_0$}\;
        $\omega \leftarrow$ \New{($\I$, $\C$)}\tcc*{Generate an initial solution}

        \ForEach{$t_m \in t$}
        {
          $k \leftarrow 0$ \tcc*{Initialize repetition counter}

          \ForEach{$k \in \{0, 1, ..., n_K$}
          {
            $\bar{\omega} \leftarrow $ \Pert{($\I$, $\C$)}\tcc*{Perturb the solution}
            $\Omega_{\bar{\omega},\omega} \rightarrow$ \Obj{$\bar{\omega}$} - \Obj{$\omega$}\tcc*{Calculate the difference of fitness scores}

            \tcc{Compare and update current solution}
            \If{$\Omega_{\bar{\omega},\omega} \le 0$}{$\omega \leftarrow \bar{\omega}$}
            \If{$\Omega_{\bar{\omega},\omega} > 0$}{$\omega \leftarrow \bar{\omega}$ with probability $e^{\frac{-\Omega_{\bar{\omega},\omega}}{t_m}}$}
          }
        }
  }
\end{algorithm}

\subsection{SA PAP Pseudo Code}
\label{sec:sa-pap-pseudo-code}
Now that the general SA algorithm has been outlined, the objective is now to outline SA-PAP (\ref{alg:sa-pap}). While
the SA PAP generally is written almost identically to that of the general SA algorithm, the general SA assumes that the
generated candidate solutions are in the solution space of the problem, \(\omega \in S\) where \(S\) is the solution space.
Initialization and the perturbation of a schedule must be verified to ensure that the generated schedule is in the
solution space. Therefore, the objective function and constraints introduced in \ref{sec:constraints} and
\ref{sec:objective-function}, respectively, must be employed to verify that the output of
\ref{alg:charge-schedule-generation} is in the feasible space, \(S\).

As previously stated, the generating functions directly influence the values of the assigned charge queue, charge
initialization time, and charge completion time: \(q_i\), \(u_i\), and \(d_i\), respectively. Having generated those values,
the rest of the decision variables may be derived. Let's begin by reviewing over the packing constraints.
\ref{seq:c0}-\ref{seq:c1} are employed to enable and disable \(\sigma_{ij}\) and \(\psi_{ij}\) and \ref{seq:c2}-\ref{seq:c4} ensure
the validity of the values. \ref{seq:c5} can be directly calculated and \ref{seq:c8} is fully defined.

Changing the focus over to the dynamic constraints, similarly to what was seen with the packing constraints, the battery
dynamic constraints are also fully defined and can be calculated. \ref{seq:c6} is sequentially calculated after a given
schedule has been fully defined. \ref{seq:c7} is evaluated to ensure the BEB is not overcharged. The penalty method
implemented in \ref{sec:objective-function} is set in place to allow the SOC to go below the specified threshold, \(\nu_{\Xi_i}
\kappa_{\Xi_i}\), but punish the solution for doing so. Thus, over time, the candidate solutions will be encouraged toward a
solution that does not activate the penalty method (i.e. is solution is truly feasible).

The SA-PAP algorithm in \ref{alg:sa-pap} will now be outlined. Line 2 initializes the SA algorithm by creating a vector
of temperature values based on a temperature schedule \(\Tau\), and initial temperature \(\Tau_0\). Line 3 generates the
initial candidate solution \(\omega\), note that \(CSG(\cdot)\) (candidate solution generator) is used to denote the specific
candidate solution generator being utilized. For SA PAP it is \ref{alg:charge-schedule-generation}. Line 4 loops through
each of the step in the temperature schedule \(t_m \in t\). Line 5 resets the iteration count to 0. Line 6 specifies the
inner loop that iterates \(n_K\) times at a constant temperature, \(t_k\). Line 7, perturbs the active solution \(\omega\) to a
neighboring candidate solution \(\bar{\omega} = PS(\omega)\), where \(PS(\cdot)\) (perturb schedule) is \ref{alg:perturb-schedule}. Line 8
calculates the difference in the fitness of \(\omega\) and \(\bar{\omega}\). Lines 8-14 are similar to \ref{alg:sa-pseudo} where it
updates \(\omega\) with \(\bar{\omega}\) if the candidate solution is more fit, or updates \(\omega\) with \(\bar{\omega}\) with probability
\(e^{\frac{-\Delta_{\bar{\omega},\omega}}{t_m}}\) if the candidate solution is less fit than the active solution. What makes these lines
unique is that the active solution is only updated if the candidate is within the solution space. That it, it satisfies
the constraints defined in \ref{eq:constraints}.

\begin{algorithm}[H]
  \scriptsize
  \caption{Simulated annealing approach to the position allocation problem} \label{alg:sa-pap}
  \LinesNumbered
  \TitleOfAlgo{SA PAP}
  \KwIn{($\I$ , $\C$)}
  \KwOut{($\bar{\I}$, $\bar{\C}$)}

  \SetKwFunction{Temp}{$\Tau$}
  \SetKwFunction{CSG}{CSG}
  \SetKwFunction{PS}{PS}
  \SetKwFunction{Obj}{J}

  \Begin
    {
      \tcc{Generate vector of temperatures given temperature function $\Tau$ and initial temperature $\Tau_0$}
      $t \leftarrow$ \Temp{$\Tau_0$}

      $\omega \leftarrow$\CSG{($\I$, $\C$)}\tcc{Generate an initial solution}

      \tcc{For each item in the temperature vector}
      \ForEach{$t_k \in t$}
       {
         $k \leftarrow 0$\tcc*{Initialize repetition counter}

        \tcc{For each step in the repitition schedule}
        \ForEach{$t_m \in t$}
        {
          $\bar{\omega} \leftarrow$ \PS{($\I$, $\C$)} \tcc*{Generate a new solution}
          $\Omega_{\bar{\omega},\omega} = $ \Obj{$\bar{\omega}$}  - \Obj{$\omega$} \tcc*{Calculate the difference of fitness scores}

          \If{$\bar{\I} \in S$ and $\Omega_{\bar{\omega},\omega} \le 0$}{$\omega \leftarrow \bar{\omega}$}
          \If{$\bar{\I} \in S$ and $\Omega_{\bar{\omega},\omega} > 0$}{$\omega \leftarrow \bar{\omega}$ with probability $e^{\frac{\Omega_{\omega, \bar{\omega}}}{t_k}}$}
        } % For k
      }   % For t_k \in t

      \Return{($\bar{\I}$ , $\bar{\C}$)}
    } % Begin
\end{algorithm}

\section{Example}
\label{sec:example}
An example is now provided to demonstrate the utility of the developed SA charge scheduling technique. In
\ref{sec:beb-scenario} a description of the example scenario is presented followed by a brief introduction of the original
MILP PAP. An alternative heuristic based planning strategy called Qin-Modified, and a heuristic modification to the SA
PAP are also used as comparisons to the SA PAP technique presented in this work. \ref{sec:results} presents the results for
each of planning strategies. The results are also analyzed and discussed.

\subsection{BEB Scenario}
\label{sec:beb-scenario}
The test scenario was run over a time horizon of \(T=24\) hours, with a total of \(n_V = \N\) visits to the station shared
between \(n_B = \A\) buses. Each BEB has a battery capacity of \(\kappa_b =\) \batsize kWh battery that is required to stay above
an SOC of \(\nu_b =\) \mincharge (\fpeval{\batsize * \minchargeD} kWh). Each bus is assumed to begin the working day with \(\alpha
=\) \fpeval{\acharge*100}\% charge (\fpeval{\acharge * \batsize} kWh). Each bus is also assumed have a rate of discharge
of \(\Delta =\) 30 kW. The penalty method employs a gain of \(D = \Cgain\). A total of \(n_C =\) \fpeval{\fast + \slow} chargers
are utilized where \slow of the chargers are slow charging (\slows kW) and \fast are fast charging (\fasts kW). As
previously introduced, to encourage the SA PAP to utilize the fewest number of chargers, the value of \(\epsilon_q\) in the
objective function is \(\forall q \in \{1,2,..., n_B \}; \epsilon_q = 0\) and \(\forall q \in \{n_b + 1, n_b + 2,..., n_Q \}; \epsilon_q = 100q\). The SA
algorithm utilizes the geometric cooling schedule with an initial temperature of \(T_0 = \tempinit\) with \(\beta_2 = 0.999\),
resulting in a total of \(n_M = \tempcnt\) steps. The demand cost is taken over fifteen minute intervals. Thus let the
demand cost be denoted as the peak-15 with the associated symbol \(p_{15}\). A weight vector of \([3, 3, 2, 1]\) was used to
influence the distribution of selecting the new charger, new window, wait, and slide visit primitives, respectively. The
algorithm also assumes a total of \(n_K = \localcnt\) iterations for the local search at a constant temperature. In total,
that results in \fpeval{\localcnt * \tempcnt} configurations being searched. On average each constant
temperature search took an average of \(\quicklocal\) seconds to complete, resulting in a total runtime of
\fpeval{\quicklocal * \tempcnt} seconds.

\ref{sec:heuristic-implementation} introduced the idea of an alternative heuristic implementation for the SA algorithm. To
distinguish the heuristic implementation from the method derived in \ref{sec:generation-mechanisms}, let this implementation
be referred to as ``heuristic'' implementation and the previous as the ``quick'' implementation. Using the same weights for
selecting randomly selecting the primitive generators, the heuristic approach further implemented a weighted
distribution vector of \([3, 1]\) to decide whether to select a slow or fast charger, respectively. In the heuristic
approach, on average the constant temperature search took a total of \(\heuristiclocal\) seconds to complete, resulting in
a total runtime of \fpeval{\heuristiclocal * \tempcnt} seconds. The heuristic generators were expected to be
slightly slower due to its iterative approach.

One of the methods utilized to compare with the SA PAP is the MILP PAP. This framework is the original MILP
implementation of the PAP derived from \cite{qarebagh-2019-optim-sched}. The inputs to the system are the same as those
discussed above. The MILP PAP does not implement the peak-15 in its objective function. In an attempt to compare the
solution of the MILP with the SA output more directly, a similar solve time of 3600 seconds. It is of note that the
solver did not reach an optimal solution.

Another heuristic-based optimization strategy, referred to as Qin-Modified, is also employed as a means of comparison
with the results of the SA PAP. The Qin-Modified algorithm is a based on the threshold strategy of
\cite{qin-2016-numer-analy}. The algorithm has been modified slightly to accommodate the case of multiple charger types
without a heuristic search for the best charger type. The heuristic is based on a set of rules that revolve around the
initial charge of the bus at visit \(i\). There are three different thresholds, low (85\%), medium (90\%), and high (95\%).
Buses below the low threshold are prioritized to fast chargers then are allowed to utilize slow chargers if no fast
chargers are available. Buses between the low and medium threshold prioritize slow chargers first and utilize fast
chargers only if no slow chargers are available. Buses above the medium threshold and below high will only be assigned
to slow chargers. Buses above the high threshold will not be charged. Once a bus has been assigned to a charger, it
remains on the charger for the duration of the time it is at the station, or it reaches 95\% charge, whichever comes
first. The previously described simulations were run on a machine equipped with an AMD Ryzen 9 5900X 12 -
Processor (24 core) at 4.95GHz \cite{gurobi-2021-gurob-optim}.


\subsection{Results\footnote{Update comparisons after new data is applied}}
\label{sec:results}
The schedules generated by their respective framework is presented in \ref{fig:schedule}. \ref{subfig:schedule-quinn}
represents the schedule generated by the Qin Modified algorithm, \ref{subfig:schedule-milp} is the schedule generated by
the MILP PAP framework, \ref{subfig:schedule-heuristic-sa} is the schedule created by the heuristic strategy in the SA
PAP algorithm, and \ref{subfig:schedule-quick-sa} is the schedule created by the quick strategy presented in this work.
The most obvious comparison between the different schedules is the minimization of the total chargers utilized by the
schedule and the perceived organization of the Qin, MILP PAP, and heuristic SA strategy as compared to the quick SA
strategy. The Qin-Modified schedule utilizes four fast and slow chargers. With at most two fast and three slow chargers
being utilized at any given moment as shown in \ref{subfig:fast-charger-usage-milp-qinn} and
\ref{subfig:slow-charger-usage-milp-qinn}. The MILP PAP framework generated a schedule that utilizes three fast charges
and four slow chargers as shown in \ref{subfig:schedule-milp}. This schedule utilizes at most two fast charges and four
slow chargers simultaneously as represented in \ref{subfig:slow-charger-usage-milp-qinn}. The heuristic SA strategy
created its schedule with nine slow charger queues (charger eight not being utilized) and four fast charging queues as
shown in \ref{subfig:schedule-heuristic-sa}. The heuristic approach uses has a peak of eight slow chargers and three
fast chargers used at any given moment as shown in \ref{subfig:fast-charger-usage-sa} and
\ref{subfig:slow-charger-usage-sa}. The quick strategy for the SA algorithm created a schedule utilizing fifteen slow
and fast chargers as is demonstrated in \ref{subfig:schedule-quick-sa}. The schedule only utilizes five slow chargers
and four fast chargers simultaneously as shown in \ref{subfig:fast-charger-usage-sa} and
\ref{subfig:slow-charger-usage-sa}. That is to say, the Qin-Modified, MILP PAP, and the heuristic SA schedules were more
efficient in the minimization of the charger count than the quick SA technique. The MILP produced a schedule with a
three charger gap in the fast queues, where the intermediate queues were never used, with minor opportunity to further
optimizing the packing of the schedule. The heuristic SA had a one charger gap with more room for more optimal packing
than the MILP. The Qin-Modified, while using the fewest chargers overall, also suffers a lack of optimality in its
packing of the schedule.

Furthermore, MILP PAP and heuristic strategy for the SA utilize the smallest index of the slow and fast chargers more
efficiently than the Qin-Modified and quick strategies (\ref{fig:schedule}). The quick schedule, while having bias
toward the slow chargers, evenly disperses the utilization of each charger among their relative charger types while the
other MILP and heuristic strategy emphasize the usage of the first charger of each type as much as possible and utilizes
other chargers when necessary.

\ref{fig:charge} depicts the SOC of each BEB throughout the simulation of each framework. The MILP PAP requires each BEB
to stay above an SOC of 25\% while the quick and heuristic SA approaches heavily penalize a schedule for allowing a BEB
to go below the 25\% SOC threshold. The MILP PAP was able to successfully keep the SOC above the threshold
(\ref{subfig:milp-charge}) while both SA approaches were not. The SOC of the quick SA approach dropped to the 50 kWh at
the end of the working day (\ref{subfig:sa-quick-charge}) and the heuristic approach reach the 50 kWh SOC mark at about
the sixteenth, eighteenth, and at the end of the working day (\ref{subfig:sa-heuristic-charge}). The Qin model allowed
the SOC of three BEBs to reach an SOC of 0\% as shown in \ref{subfig:qin-charge}. As to be expected, no model allowed the
SOC to go above the battery capacity, \(\kappa\).

\ref{fig:power} depicts the power consumption over the time horizon for each model. Although the SA algorithm is
equipped with the peak-15 in its objective function, the heuristic SA implementation has the largest peaks in power
consumption at about 2700 kW (\ref{fig:power-usage-sa}). The next largest peaks are by the MILP PAP, Qin-Modified, and
quick SA approach at about 1900-2000 kW (\ref{fig:power-usage-milp-qin} and \ref{fig:power-usage-sa}). It is again worth
noting here that the Qin-Modified technique was unable to keep the SOC above 0\%. The MILP PAP has a mean power
consumption of 177.34 kW the Qin-Modified has a mean of 351.36 kW (\ref{fig:power-usage-milp-qin}). The quick SA has a
mean power consumption of 297.04 kW and the heuristic SA has a mean of about 241.04 kW (\ref{fig:power-usage-sa}). Their
max values are 2732.85 kW, 1941.9 kW, 1910 kW, and 1880 kW for the heuristic, quick, MILP, and Qin-Modified strategies,
respectively.

The last comparison made is the energy consumed by the created schedule. The total energy consumed by each schedule is
shown in \ref{fig:energy-usage}. The ordering of most energy consumed to least is as follows: Qin-Modified, quick SA,
heuristic SA, and the MILP PAP. The respective energy consumption for each technique is: 8432.64 kWh, 7243.56 kWh,
5785.76 kWh, and 4256.16 kWh. The heuristic SA consuming about 1529.6 kWh more than the MILP PAP. The quick and
heuristic SA techniques surpass the energy consumption of the MILP PAP at about the eighth hour. At about the thirteenth
hour, the heuristic SA fall below the MILP-PAP until about the fifteenth hour.

\begin{figure}
  \centering
  %%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  % Qin
  \begin{subfigure}[t]{\textwidth}
    \centering
    \includegraphics{img/schedule-quinn}
    \caption{Charging schedule generated by Qin Modified algorithm.}
    \label{subfig:schedule-quinn}
  \end{subfigure}

  \hfill

  %%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  % MILP
  \begin{subfigure}[t]{\textwidth}
    \centering
    \includegraphics{img/schedule-milp}
    \caption{Charging schedule generating by the MILP PAP algorithm.}
    \label{subfig:schedule-milp}
  \end{subfigure}
\end{figure}

\begin{figure} \ContinuedFloat
  \centering

  %%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  % SA heuristic
  \begin{subfigure}[t]{\textwidth}
    \centering \includegraphics{img/schedule-sa-heuristic}
    \caption{Charging schedule generated by the SA PAP algorithm using the heuristic strategy.}
    \label{subfig:schedule-heuristic-sa}
  \end{subfigure}

  \hfill

  %%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  % SA quick
  \begin{subfigure}[t]{\textwidth}
    \centering \includegraphics{img/schedule-sa-quick}
    \caption{Charging schedule generated by SA PAP algorithm using the quick strategy.}
    \label{subfig:schedule-quick-sa}
  \end{subfigure}
  \caption{Vairous schedules generated by the different frameworks. Nodes of the same color and shape connected by lines of the same color (whether dashed or solid) represents a charging schedule for a singular BEB. The horizonontal line stemming from the nodes ending with a vertical tick indicate the charge duration for that particular visit.}
  \label{fig:schedule}
\end{figure}

\begin{figure}
    %%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    % Fast
    \begin{subfigure}[t]{\textwidth}
    \centering
        \includegraphics{img/charger-count-fast-milp-qin}
        \caption{Number of fast chargers for Qin and MILP PAP.}
        \label{subfig:fast-charger-usage-milp-qinn}
    \end{subfigure}

    \begin{subfigure}[t]{\textwidth}
    \centering
        \includegraphics{img/charger-count-fast-sa}
        \caption{Number of fast chargers for quick and heuristic SA executions.}
        \label{subfig:fast-charger-usage-sa}
    \end{subfigure}
\end{figure}

\begin{figure}
    %%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    % Slow
    \begin{subfigure}[t]{\textwidth}
    \centering
        \includegraphics{img/charger-count-slow-milp-qin}
        \caption{Number of slow chargers for Qin and MILP PAP.}
        \label{subfig:slow-charger-usage-milp-qinn}
    \end{subfigure}
    \begin{subfigure}[t]{\textwidth}
    \centering
        \includegraphics{img/charger-count-slow-sa}
        \caption{Number of slow chargers for the quick and heuristic SA executions.}
        \label{subfig:slow-charger-usage-sa}
    \end{subfigure}
\end{figure}

\begin{figure}
  %%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  % Qin
  \begin{subfigure}[t]{\textwidth}
    \centering
    \includegraphics{img/charge-quinn}
    \caption{Bus charges for the Qin Modified charging schedule. The charging scheme of the Qin charger is more predictable during the working day.}
    \label{subfig:qin-charge}
  \end{subfigure}
  \hfill
  %%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  % MILP
  \begin{subfigure}[t]{\textwidth}
    \centering
    \includegraphics{img/charge-milp}
    \caption{The bus charges for the MILP PAP charging schedule. The MILP model allows for guarantees of minimum/maximum changes during the working day as well as charges at the end of the day.}
    \label{subfig:milp-charge}
  \end{subfigure}
  \hfill
\end{figure}

\begin{figure}\ContinuedFloat
  %%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  % SA Quick
  \begin{subfigure}[t]{\textwidth}
    \centering
    \includegraphics{img/charge-sa-quick}
    \caption{The bus charges for the SA PAP charging schedule. The SA model allows for guarantees of minimum/maximum changes during the working day as well as charges at the end of the day.}
    \label{subfig:sa-quick-charge}
  \end{subfigure}
  \hfill
  %%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  % SA Heuristic
  \begin{subfigure}[t]{\textwidth}
    \centering
    \includegraphics{img/charge-sa-heuristic}
    \caption{The bus charges for the SA PAP charging schedule. The SA model allows for guarantees of minimum/maximum changes during the working day as well as charges at the end of the day.}
    \label{subfig:sa-heuristic-charge}
  \end{subfigure}
  \caption{}
  \label{fig:charge}
\end{figure}

\begin{figure}
  \begin{subfigure}[t]{\textwidth}
    \centering
    \includegraphics{img/power-milp-qin}
    \caption{Amount of power consumed by Qin-Modified and MILP schedule over the time horizon.}
    \label{fig:power-usage-milp-qin}
  \end{subfigure}

  \hfill

  \begin{subfigure}[t]{\textwidth}
    \centering
    \includegraphics{img/power-sa}
    \caption{Amount of power consumed by Qin-Modified and MILP schedule over the time horizon.}
    \label{fig:power-usage-sa}
  \end{subfigure}
  \caption{}
  \label{fig:power}
\end{figure}

\begin{figure}[htpb]
\centering \includegraphics{img/energy}
    \caption{Total accumulated energy consumed by the Qin-Modified and MILP schedule throughout the time horizon.}
    \label{fig:energy-usage}
\end{figure}


\section{Conclusion}
\label{sec:conclusion}
This work developed an SA implementation derived from the works of the MILP PAP. The model is designed to reduce the
total number of utilized chargers, minimize the peak energy consumption and the total energy consumed. The problem
description was provided outlining the scenario in which this model is designed for. The optimization problem was then
introduced by describing the components of the objective function and outlining the MILP constraints utilized to ensure
candidate solutions are in the solution space.

The objective function derived in this work is composed of two main pieces: the assignment cost and the utility cost.
The assignment cost consists of the cost of assigning a BEB to a particular queue and a penalty function. The cost of
assigning a BEB to an idle queue (a queue that provides no charge) has no cost. However, the cost of assigning a BEB to
a charge queue, ordered first by slow then fast chargers, is scaled by a constant gain factor multiplied by the queue
index. The penalty method was implemented to keep the SOC of each BEB above a specified charge threshold. If the initial
SOC of a BEB upon an arrival to the station is below the threshold, a large penalty is applied to the objective that is
proportional to the difference of the BEB SOC and the threshold squared. The utility cost consists of the consumption
cost and the demand cost. The consumption cost is the total accumulated energy of the schedule and the demand cost is
described by the peak-15 (peak power consumption).

An example of the SA PAP algorithm was then presented and compared the MILP PAP and Qin-Modified techniques. The SA PAP
was run utilizing two different neighborhood searching techniques named the quick and heuristic techniques,
respectively. The quick SA's objective was to randomly search a wide neighborhood while the heuristic technique was
designed to incrementally search a neighborhood by randomly selecting a fast or slow charging queue and then stepping
through the queues one at a time. The quick and heuristic have comparable run times at \fpeval{\quicklocal * \tempcnt} seconds and \fpeval{\heuristiclocal * \tempcnt} seconds, respectively. The Qin-Modified and MILP
PAP utilized the fewest amount of chargers. The heuristic SA technique generated a solution approximating that of the
MILP and Qin-Modified, but was unable to minimize the charger count as efficiently. The quick SA utilized all the
chargers available (i.e. was unable to minimize the charger count).

Both of the SA techniques were unable to keep the SOC above the 25\% SOC threshold with SOC falling to about 50 kW for
the quick and 10 for the heuristic. The Qin-Modified had the SOC of three BEBs fall to 0\% SOC. The schedule that
consumed the least amount of energy is the MILP PAP (4256.16 kW) with the heuristic SA coming in second (5785.76 kW).
The difference between the two being about \fpeval{5785.76 - 4256.16} kWh.

Further fields of interest are to investigate the performance of the quick and heuristic SA approaches utilizing a denser
set of routes to schedule. It is also of interest to incorporate non-linear battery dynamics to more accurately model
the SOC. Furthermore, ``fuzzifying'' the charge times is of interest to allow flexibility in the initial and final charge
times for each BEB visit.

\bibliographystyle{plain}
\bibliography{/home/alex/Documents/citation-database/lit-ref,/home/alex/Documents/citation-database/lib-ref}
\end{document}
