* Simulated Annealing
:PROPERTIES:
:CUSTOM_ID: sec:simulated-annealing
:END:
SA is a well-studied local search metaheuristic used to solve discrete and (to a lesser degree) continuous problem
[cite:@gendreau-2018-handb-metah]. A metaheuristic is a high-level problem-independent algorithm framework that provides
a set of guidelines or strategies to develop heuristic optimization algorithms [cite:@radosavljevic-2018-metah-optim].
Metaheuristic problems primarily fit in two categories: population-based and single-solution-based. Population based
algorithms emphasize exploration of the solution space as apposed to single-solutions-based algorithms being more
exploitation oriented [cite:@radosavljevic-2018-metah-optim]. Generally, metaheuristic algorithms share the basic
advantage of speed in finding a satisfactory solution for large-scale practical optimization problems
[cite:@radosavljevic-2018-metah-optim]. SA, however, is sometimes criticized for the speed at which it converges to the
global optimum [cite:@gendreau-2018-handb-metah; @henderson-1989-theor-pract].

SA is an exploitation oriented, single-solution based metaheuristic with, in addition the previously stated, advantages
of simplicity, both theoretically and implementation, as well as its inherit ability to overcome non-linearities
[cite:@gendreau-2018-handb-metah;@radosavljevic-2018-metah-optim]. This model is named after its analogized process
where a crystalline solid is heated then allowed to cool at a slow rate until it achieves its most regular possible
crystal lattice configuration [cite:@henderson-1989-theor-pract]. SA establishes a connection between this thermodynamic
and searching for global optima for an optimization problem.

There are five key components to SA: initial temperature, cooling schedule (temperature function), generation
mechanisms, acceptance criteria, local search iteration count (temperature change counter)
[cite:@keller-2019-multi-objec]. The temperature solution describes the speed at which the system is "cooled" over each
iteration. The temperature of the system describes the likelihood that a system is willing to explore the solution
space. The generation mechanisms provide a means of modifying the system by some singular discrete change that is within
the neighborhood [cite:@gendreau-2018-handb-metah]. The acceptance criteria is a function of the system temperature that
makes the decision whether the system will accept an inferior solution in favor of exploring the solution space.
Finally, the local search iteration count is the number of steps taken to try to exploit a solution at a constant
temperature. Each of these mechanisms are elaborated in the subsequent sections.

** Cooling Equation
:PROPERTIES:
:CUSTOM_ID: cooling-equation-experimental
:END:
The temperature function models a "rate of cooling" for the SA process. Initially, when the temperature is high, SA
encourages exploration. As the process begins to "cools down" (in accordance to the cooling schedule), it begins to
encourage local exploitation of the solution (rather than exploration)
[cite:@rutenbar-1989-simul-anneal-algor;@henderson-1989-theor-pract]. There are three common basic types of cooling
equations: linear, geometric, and exponential. Each schedule is depicted in [[fig:cool]] [cite:@keller-2019-multi-objec].
Each plot begin with an initial temperature of $500^\circ\; C$ and a final temperature of $1^\circ\; C$. The different cooling
schedules dictate the rate at which the algorithm progressively disallows exploration. A linear cooling schedule is
defined by [[eq:cool0]].

#+name: eq:cool0
\begin{equation}
\Tau[n] = \Tau[n-1] - \Delta_0
\end{equation}

with $\Tau[0] = \Tau_0$ and $\Delta_0 = 1/2\; C^\circ$ in [[fig:cool]]. The value of $\Delta_0 \in \mathbb{R}^+$. A geometric cooling schedules is as
defined in [[eq:cool1]]. The cooling schedule type most widely used in practice [cite:@keller-2019-multi-objec]. As such, it
will also be employed by the work in this paper.

#+name: eq:cool1
  \begin{equation}
  \Tau[n] = \alpha \Tau[n-1]
  \end{equation}

where $\alpha = 0.995$ in [[fig:cool]]. $\alpha$ may vary anywhere between the range $[0,1)$. An Exponential cooling schedule is
defined by the difference equation is defined as [[eq:cool2]].

#+name: eq:cool2
\begin{equation}
\Tau[n] = e^{-\beta}\Tau[n-1]
\end{equation}

where $\beta = 0.01$ in [[fig:cool]]. A typical range for $\beta$ is $0.8 \le \beta \le 0.99$ [cite:@delahaye-2019-simul].

#+name: fig:cool
#+ATTR_ORG: :width 200
#+ATTR_LATEX: :width 0.5\textwidth
#+caption: Cooling equations
[[file:img/cool_func.png]]

** Acceptance Criteria
:PROPERTIES:
:CUSTOM_ID: sec:acceptance
:END:
In SA, the algorithm stores a candidate solution that is continuously compared to newly generated solutions. Let the
stored solution be referred to as the "active solution". During each iteration, a new candidate solution is generated
and compared to the active solution to determine if the new solution should replace the active solution. In order to
determine if the active solution is to be replaced, an acceptance criteria is defined. A new candidate solution that is
more fit than active solution (fitness being dictated by the objective function) is always accepted as the new active
solution. In an effort to encourage exploration, inferior candidate solutions have a probability of being accepted as
the active solution. The probability of accepting an inferior candidate solution is described by the function
$\exp(-\frac{J(x) - J(\bar{x})}{\Tau})$ where $J(\cdot)$ is the objective functions described in [[#sec:objective-function]] and
$\Tau$ is current temperature. The probability of acceptance is a function of the current temperature and the difference
of the active solution and a new candidate solution. Formally, let $\Delta E \equiv J(x) - J(\bar{x})$ where $x$ is the current
solution and $\bar{x}$ is the new candidate solution. Let $f(\cdot)$ be the function that describes the probability of
accepting a candidate solution $\bar{x}$, and is defined by [[eq:candaccept]] [cite:@keller-2019-multi-objec].

#+name: eq:candaccept
\begin{equation}
f(x,\bar{x},T) =
\begin{cases}
  1                   & \Delta E > 0 \\
  e^{- \frac{\Delta E}{T}} & \text{otherwise}
\end{cases}
\end{equation}

** Generation Mechanisms
:PROPERTIES:
:CUSTOM_ID: sec:generation-mechanisms
:END:
Generation mechanisms are used to create a neighboring candidate solution [cite:@gendreau-2018-handb-metah]. That is,
the generating function creates a solution that can be reached in a single iteration from the active solution. In the
case of the problem statement made in [[#sec:problem-description]], six primitive generation mechanism shall be used: new
visit, slide visit, new charger, wait, new window, and purge. The purpose of each of these generators is to assign new
visits to a charger, adjust a bus visits initial and final charge time within the same time frame/queue, move a BEB from
one charger to another with the same charge schedule, move a bus to its waiting queue, and remove a charger from the set
of charger availability's. Each generator will be discussed in more detail in [[#sec:generators]].

These generator mechanisms will in turn be utilized by two wrapper functions. The schedule generation is to used create
an initial candidate solutions for SA to compare with other solutions, and the perturb schedule generator is used to
take a candidate solution and alter it slightly in an attempt to fall into a global/local minimum. The wrapper functions
will be discussed in [[#sec:generator-wrappers]]. However, prior to discussing the primitives and wrapper generating
functions, their respective inputs and outputs must be defined.

*** Generator Input/Output
:PROPERTIES:
:CUSTOM_ID: sec:generator-input-output
:END:
This section discusses in detail the expected inputs and outputs of each generator. It is important to discuss these
parameters to have an understanding of the generator algorithms to be derived. The input consists of the bus visit index
of interest, information about the current state of visits, $\I$, and the current state of the charger availability,
$\C$. The availability of each charger, $\C$, is iteratively constructed throughout the SA process. The output of each
generator affects the tuple of decision variables $(v_i, u_i, d_i)$ and charger availability $\C$.

**** Generator Input
Each generator accepts an input of the tuple of the form $\Sol \equiv (i, \I, \C)$ where $i$ is the visit index being
manipulated, $\I$ is the tuple that describes the set of visits, and $\C$ is the set that describes the availability for
all chargers $q \in \Qset$. In other words, $\C$ defines the set of times when the chargers are not being utilized or are
"inactive".

To derive $\C$, consider its complement, $\C'$, which is the set of "active" time periods for each charger. Let $\C_q' \subset
\C'$ describes the active times for charger $q$. Focusing on an individual charger, consider $\C_q'$ before a schedule
has been imposed upon it, $\C_q' = \{ \varnothing \}$. In other words, no buses have been assigned to be charged over
some time period $[u_i, d_i]$. After the scheduling process is complete, $\C_q'$ will have a set of active periods of
the form $\C_q' = \{[u_j, d_j]: j \in \Jsetq \}$ where $\Jsetq \subset \mathcal{I}$. With a fully defined set $\C_q'$, its compliment can
be found, $\C_q$.

Let $j\text{th}$ inactive period shall be denoted as $\C^j_q$. To determine the inverse of $\C_q'$, begin by noting
$\C_q' \bigcap \{[u_j, d_j] : j \in \Jsetq\} = \varnothing$, is said to be disjoint (i.e. the sets share no common elements)
[cite:@halmos-1974-naive-set-theor]. The inverse of a disjoint set can be found by the De Morgan Law: $(A \cap B)' = A' \cup
B'$. Using De Morgan's Law, the set of inactive periods can be written as $\C_q \equiv \bigcup \{[u_j, d_j]': j \in \Jsetq\}$.

**** Generator Output
The output of the generating functions is a modified subset of an input tuple. Let a modified input tuple be denoted as
$\bar{\Sol}$ and the modified subset of the tuple be defined by $\bar{x}_i \equiv (\bar{v_i}, \bar{u_i}, \bar{d_i},
\bar{\C})$, (as opposed to $x_i$ being unmodified). To be explicit, $\bar{x}_i$ consists of the modified charger
inactive times and the direct decision variables: the chosen queue, initial charge time, and detach time from the
charger. The other direct variables and indirect variables may be implied.

*** Generators
:PROPERTIES:
:CUSTOM_ID: sec:generators
:END:
This section describes and outlines the algorithm pool for the different generator types that are utilized in the
wrapper functions. Recall that to satisfy constraints, $n_B$ extra idle queues are added that provide no power to the
BEB. Because of this, the set of queues is fully defined as $q \in \{1,..., n_B, n_B+1,..., n_Q+n_B\}$ where $n_Q$ is the
total amount of chargers and $n_B$ number of BEBs. The use case for the idle queues are for when a bus is not to be
placed on a charger. Rather, it will be placed in the queue, $v_i \in \{1,..., n_B\}$, which satisfies the previously
defined spatial constraints while allowing the bus to be "set aside".

In the development of the algorithms, dot notation is to be introduced to extract variables from tuples. For example,
suppose the arrival time is desired to be extracted from visit $i$. Given $\Sol$, the notation that describes extracting
the initial visit $u_i$ is written as $u_i \equiv \I_{i.u}$.

**** New visit
:PROPERTIES:
:CUSTOM_ID: sec:new-visit
:END:
The new visit generator describes the process of moving an unsigned BEB $b \in B$ to a charging queue, $v_i \in \{n_B+1,...,
n_B + n_Q\}$ within its arrival/departure time $[a_i, e_i]$. Let $\U_{\cdot}$ indicate that an element is selected randomly
with a uniform distribution from the set $\{\cdot\}$. For example, $\U_{[a_i, e_i]}$ indicates that a value will be selected
between $a_i$ and $u_i$ with a uniform distribution. Lines 2 and 3 of \ref{alg:new-visit} extract the arrival and
departure times of visit $i$. Note that in subsequent algorithms these lines will be omitted for conciseness. Lines 4
and 5 select a charging queue, $q$, and time slice for which $q$ is available at random with uniform distributions,
respectively. Line 6 quickly verifies that the inactive period selected is viable and returns a random charging time,
$[u_i, d_i]$. If the time frames of the visit and the charger availability do not align, the null value is returned.

The function =findFreeTime= is the algorithm that determines whether a visit's time at the station $[u_i, e_i]$ can be
placed in the time availability of charger $q$. The algorithm is defined in \ref{alg:find-free-time}. Let $L$ and $U$ be
the lower and upper bound of the time between scheduled times. The set of cases is shown in [[fig:find-free]]. In each case
depicted by [[fig:find-free]], the red line shows the arrival and departure time for a BEB visit, $i$. The blue lines
indicate regions in which charger $v_i$ is active. $C \in \C_q$ represents one of the ranges between the blue lines, $[L,
U]$.

The =findFreeTime= algorithm behaves as follows. Lines 1 and 2 of \ref{alg:find-free-tim} extract the lower and upper
bounds of the charger availability. Lines 3 - 20 check whether the BEB visit can be assigned to the charger available
time slice. Lines 4 - 6 relate to the scenario in \ref{subfig:sandwich}. That is, the BEB visit fits entirely within the
charger availability and the charge time may be anywhere in the range $[a_i, e_i]$. Lines 8 - 11 coincides with
\ref{subfig:all} where the arrival time is before the charger is available. Therefore, the BEB may charge anywhere in
the time $[L, e_i]$. On the opposite end, Lines 12 - 15 represents the scenario in \ref{subfig:egu} represents the
scenario in which the BEB departs after the upper bound of the charger availability. Thus, the BEB may be charged
anywhere in the time frame of $[a_i, U]$. Naturally, Lines 16 - 19 corresponds to the scenario in
\ref{subfig:invertsandwhich} where the upper and lower bound of the visit is constrained by the charger availability
such that the time that the BEB can charge is $[L,U]$. Lines 24-28 relate to the scenarios in which the BEB visit does
not fall within the charger availability time slice. Line 27 returns the updated charger availability. Line 30 returns
the original charger availability and null values for the charge times upon failure.

#+include: eq/new-visit.org
#+include: img/find-free.org
#+include: eq/find-free.org

**** Purge
:PROPERTIES:
:CUSTOM_ID: sec:purge
:END:
The purge primitive generator simply removes a visit from a charger schedule, $\C$. This generator exists so that other
primitive generators may place the visit back into the schedule without creating duplicate entries in $\C$. Line 2 from
\ref{alg:purge} updates $\C$ with the set of visits excluding visit $i$. Line 3 returns the updated set of charger
availability.

#+include: eq/purge.org

**** Slide visit
:PROPERTIES:
:CUSTOM_ID: slide-visit
:END:
Slide visit is used for buses that have already been scheduled. Because of the constraint \ref{seq:c10} there may be
some room to manipulate $u_i$ and $d_i$ within the window $[a_i, e_i]$. Two new values, $u_i$ and $d_i$ are randomly
selected with a uniform distribution that satisfy the constraint $a_i \leq u_i \leq d_i \leq e_i$. Line 2 from
\ref{alg:slide-visit} purges the visit from the charger availability set. Line 4 retrieves the window that was opened up
by purging visit $i$. Line 4 sets the new charge time frame, $[u_i, d_i]$. Line 5 the updated visit. If =findFreeTime=
was unsuccessful, then the generator returns a tuple of null values.

#+include: eq/slide-visit.org

**** New charger
:PROPERTIES:
:CUSTOM_ID: new-charger
:END:
The new charger generator (shown in \ref{alg:new-charger}) moves a visit $\I_i$ to a new charging queue while
maintaining the same charge time, $[u_i, d_i]$. Line 2 purges the visit from the charger availability set. Line 3
randomly selects a charger queue index, $q$. Line 4 checks if there is an available time slice $[a_i, e_i]$ for charger
$q$. Line 5 sets and returns the updated visit. If =findFreetime= was unsuccessful, then the generator returns a tuple
of null values.

#+include: eq/new-charger.org

**** Wait
:PROPERTIES:
:CUSTOM_ID: sec:wait
:END:
The wait generator simply removes a bus from a charger queue and places it in its idle queue, \(v_i \in \{1,...,B\}\).
Line 2 from \ref{alg:wait} purges the visit from the charger availability set. Line 4 updates the charger availability
set of the wait queue for bus $b$. Note that $C_L \le u_i \le d_i \le C_U$. Line 4 returns the updated visit.

#+include: eq/wait.org

**** New Window
:PROPERTIES:
:CUSTOM_ID: sec:new-window
:END:
New window is a combination of the purge and then new visit generators. By this it is meant that current scheduled tuple
$(v_i, u_i, d_i)$ is purged and added back in as if it were a new visit. This implies that the BEB may be assigned to a
different queue and a new charge time slice. Line 2 purges the BEB visit from the schedule and Line 3 places the BEB
back into the schedule using the new visit generator. Line 4 assigns and returns the updated visit.

#+include: eq/new-window.org

*** Generator Wrappers
:PROPERTIES:
:CUSTOM_ID: sec:generator-wrappers
:END:
This section covers the algorithms utilized to select and execute different generation processes for the SA algorithm.
The generator wrappers are the methods immediately called by the SA algorithm. Each wrapper utilizes the generators
previously described and returns either a new charge schedule or a modified charge schedule.

**** Charge Schedule Generation
:PROPERTIES:
:CUSTOM_ID: sec:charge-schedule-generation
:END:
The objective of this generator is to assign each BEB to its waiting queue provided a schedule of routes. To generate
this starting point, the generator is given $\I$, which represents the set of unscheduled BEBs. Line 3 of
\ref{alg:charge-schedule-generation} loops through each visit.

#+include: eq/charge-schedule-generation.org

**** Perturb Schedule
:PROPERTIES:
:CUSTOM_ID: sec:tweak-schedule
:END:
As described in SA, local searches are also employed to try and exploit a given solution
[cite:@radosavljevic-2018-metah-optim]. After each step of the cooling function, the new candidate solution will be
altered by one primitive generation function and compared to the active solution. This process is done over many
iterations. That is, the local solution space shall be explored in an attempt to find an optima. The method that will be
employed to exploit the given solution is as follows: pick a visit, pick a primitive generator, and execute said
primitive generator. The algorithm is outlined in \ref{alg:perturb-schedule}. Line 2 selects a visit with a uniform
distribution. Let $n_G$ denote the number of primitive generators available and let =PGF= be the primitive generation
function, Line 3 selects a primitive generation function with a uniform distribution. Line 5 executes the generation
function.

#+include: eq/tweak-schedule.org

#  LocalWords:  metaheuristic linearities BEBs BEB
