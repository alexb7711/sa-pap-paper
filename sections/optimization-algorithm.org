* Optimization Algorithm
:PROPERTIES:
:CUSTOM_ID: sec:optimization-algorithm
:END:

This section combines the generation algorithms and the optimization problem into a single algorithm. It begins with an
introduction and discussion of a general SA algorithm which will be used to springboard into the construction of the SA
PAP algorithm.

** Simulated Annealing Pseudo Code
:PROPERTIES:
:CUSTOM_ID: sec:simulated-annealing-pseudo-code
:END:

Let $\omega$ and $\bar{\omega}$ denote the active solution and
the candidate solution, respectively. Let $\Tau$ be the temperature function and $\Tau_0$ the initial temperature.
Furthermore, let $t$ be defined as the vector of temperatures defined by $t = \Tau(\Tau_0)$, and let $t_m$ be defined as
being an element of $t$, $t_m \in t$. Let $n_K$ be the repetition counter, it defines the number of iterations to execute
exploit a solution at a constant temperature $t_m$.

Recall the objective of the SA algorithm is to iteratively create a neighboring candidate solution from the active
solution. The fitness of the two solutions are compared and if the candidate solution is of a higher quality, it is
always taken as the active solution. If it is not, then it may be selected as the new candidate solution with some
probability that is a function of the difference in the objective function values and the current temperature. This
process is iteratively done until the temperature function reaches its minimum value. With the high level summary in
mind, the SA pseudocode is to be presented [cite:@henderson-1989-theor-pract].

The algorithm behaves as follows: Lines 1 and 2 of \ref{alg:sa-pseudo} initialize the SA algorithm an active solution,
$\omega$, and temperature schedule, $t$, respectively. The outer loop on Line 3 iterates through all the temperature values
in $t$. After each iteration of the outer loop, the temperature is decreased as specified by the selected temperature
function. Line 4 resets the iteration counter to 0. Line 5 specifies the inner loop that iterates $n_K$ times at a
constant temperature, $t_k$. Line 6, perturbs the active solution $\omega$ to a neighboring candidate solution $\bar{\omega} =
N(\omega)$. Line 7 then calculates the difference in the fitness of $\omega$ and $\bar{\omega}$. Lines 8-13 updates $\omega$ with $\bar{\omega}$
if the candidate solution is more fit, or updates $\omega$ with $\bar{\omega}$ with probability $e^{\frac{-\Delta_{\omega , \bar{\omega}}}{t_m}}$
if the candidate solution is less fit than the active solution. Line 14 updates the repetition counter.

#+include: eq/sa-pseudo.org

** SA PAP Pseudo Code
:PROPERTIES:
:CUSTOM_ID: sec:sa-pap-pseudo-code
:END:

Now that the general SA algorithm has been outlined, the objective is now to outline SA-PAP in \ref{alg:sa-pap}. While
the SA PAP generally is written almost identically to that of the general SA algorithm, SA assumes that the new solution
generated is in the solution space of the problem, $\omega \in S$ where $S$ is the solution space. Referring to
\ref{alg:charge-schedule-generation}, the generating function for SA PAP, note that all the assignments are placed in
their respective waiting queues. One is to expect that the output generated by this function will not be in the solution
space for most (if not all) scenarios of any interest. Therefore, the constraints introduced in [[#sec:constraints]] must be
employed to verify that the output of \ref{alg:charge-schedule-generation} is in the feasible space, $S$.

As previously stated, the generating functions directly influence the values of the assigned charge queue, charge
initialization time, and charge completion time: $v_i$, $u_i$, and $d_i$, respectively. Having generated those values,
the rest of the decision variables may be derived. Let's begin by reviewing over the packing constraints.
\ref{seq:c0}-\ref{seq:c1} are employed to enable and disable $\sigma_{ij}$ and $\psi_{ij}$ and \ref{seq:c2}-\ref{seq:c4} ensure
the validity of the set values. \ref{seq:c5} can be directly calculated and \ref{seq:c11} is fully defined.

Now let's change the focus over to the dynamic constraints. Similar to what was seen with the packing constraints, the
battery dynamic constraints are also fully defined and can be calculated. \ref{seq:c6} is sequentially calculated while
\ref{seq:c7} is evaluated to ensure the BEB is not over charged. \ref{seq:c12}-\ref{seq:c15} may also be evaluated to
find the values of $\theta_h^{v_i}$ and $\mu_h^{v_i}$ which then directly leads to \ref{seq:c16} being able to be determined.
Once all these constraints have been calculated and evaluated to be true will a generated solution be considered in the
feasible space. Let the feasible space be denoted as $S$.

Line 2 initializes the SA algorithm by creating a vector of temperature values based on a temperature schedule $\Tau$,
and an initial temperature $\Tau_0$. Line 3 generates the initial candidate solution $\omega$, note that $CSG(\cdot)$ is used to
denote specific candidate solution generator being utilized, for SA PAP it is \ref{alg:charge-schedule-generation}. Line
4 loops through each of the step in the temperature schedule $t_m \in t$. Line 5 resets the iteration count to 0. Line 5
specifies the inner loop that iterates $n_K$ times at a constant temperature, $t_k$. Line 6, perturbs the active
solution $\omega$ to a neighboring candidate solution $\bar{\omega} = N(\omega)$. Line 7 then calculates the difference in the fitness
of $\omega$ and $\bar{\omega}$. Lines 8-14 are similar to \ref{alg:sa-pseudo} where it updates $\omega$ with $\bar{\omega}$ if the candidate
solution is more fit, or updates $\omega$ with $\bar{\omega}$ with probability $e^{\frac{-\Delta_{\bar{\omega},\omega}}{t_m}}$ if the candidate
solution is less fit than the active solution. What makes these lines unique is that the active solution is only updated
if the candidate is within the solution space. That it, it satisfies the constraints defined in \ref{eq:constraints}.

#+include: eq/sa-pap-pseudo.org
