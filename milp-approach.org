#+TITLE: Bus Charging Schedule Simulated Annealing with MILP Constraints
#+DATE: \today
#+EMAIL: A01704744@usu.edu
#+LANGUAGE: en

# =========================================================================================================================
# Preamble

#+include: preamble.org

# =========================================================================================================================
# Document

* Introduction
:PROPERTIES:
:CUSTOM_ID: sec:introduction
:END:
This document outlines the simulated annealing (SA) approach to the bus charging scheduling problem utilizing Mixed
Integer Linear Programming (MILP) constraints as the method of determining feasible charging schedules. The problem
statement is as follows: given a set of routes for a fleet of Battery Electric Buses (BEB) and a set of fast and slow
chargers, generate an optimal charging schedule to minimize the consumption cost (amount of electricity used over a
certain time) and the demand cost (rate at which electricity is being used) within the constraints that the buses must
maintain sufficient charge to complete the working day and do not have any delays in their respective routes.

Simulated Annealing (SA) shall be introduced and utilized as a means of finding optimizing. The SA algorithm shall be
constrained by a set of Mixed Integer Linear Program (MILP) constraints derived from the Position Allocation Problem
(PAP). These constraints are set in place to ensure validity of the proposed charging schedules. A set of objective
functions describing consumption cost and demand cost, as stated above, shall be minimized to reduce power consumption
and total cost of using the BEBs.

* Problem Description
:PROPERTIES:
:CUSTOM_ID: sec:problem-description
:END:
It is assumed that there are a total of $I$ visits to the station by $B$ buses. There are a total of $Q$ queues for the
bus at the station. Given a set of bus arrivals to a charging station $i \in \{1,..., I\} = \Iset \subset \mathcal{Z}$ with a set of
chargers to be queued $q \in \{1,..., Q\} = \Qset \subset \mathcal{Z}$ where the bus is indicated by an identification number $b \in
\{1,..., B\} = \Bset \subset \mathcal{Z}$. Each bus arrival, $i$, can be represented by the tuple: $\visit$, in which the ordered
elements denote the bus identification number, $b_i$, arrival time to the station, $a_i$, departure time from the
station, $e_i$, time to start charging, $u_i$, time to stop charging, $d_i$, the charger queue for the bus to be placed
into, $v_i$, and the initial State Of Charge (SOC), $\eta_i$.

It is assumed that each visit occurs over the time horizon $T = \{ t : t_0 \le t \le t_f \}$. The set of all arrivals is
represented by the set $\I = \{\forall i \in \Iset \; \visit: b_i, \xi_i \in \Bset, a_i, e_i, u_i, d_i \in T, v_i \in \Qset \}$. The
concept of "arrivals" is derived from the PAP [[cite:&Qarebagh2019]]. This idea of arrivals is useful in the sense that it
is easy to describe the state of any arbitrary arrival; however, although a bus may revisit the station multiple times,
the model assumes that each arrival is unique (i.e. no two bus arrives twice) therefore a system must be put in place to
track each bus over each arrival. That is why a bus identifier is placed in the tuple, and in that way each bus can be
tracked over each arrival.

For each arrival a bus must be placed in a singular queue, $v_i \in \Qset$. The charger $q$ is assumed to be either a fast
or slow charger or no charger at all. A bus is only allowed to visit one queue per visit; however, there may be multiple
buses charging simultaneously. The amount of time the bus is allowed to charge is dictated by the scheduled arrival time
and required departure time, $[a_i, e_i]$. Although a bus must be placed in a queue, if a bus does not require much
charge, or none at all, partial charges, or no charging, is allowed. It is not allowed for the bus to charge over its
battery capacity limit. The battery charging rate is modeled as linear, which remains accurate up to about an SOC of 80%
charge [[cite:&Li2016]].

Each bus arrival, with the exception of the last arrival for each bus, has a paired "route" that the bus must perform.
This route, as one would expect, causes the bus to discharge by some certain amount. This paper assumes an average
discharge over a period of time where an estimated discharge is calculated for each route, $\Delta_i$. The charge supplied
while at the station is required to supply enough charge for each route (battery charge does not deplete to zero) with
an additional battery capacity percentage, $m$, acting as a safety factor.

The scheduler's task shall be to schedule the set of arrivals $\I$ to fulfill the minimum charge requirements over the
time horizon $T$ as well as minimize the demand cost as well as minimize over the consumption cost. The objective
function and constraints are discussed in further detail in section [[#sec:objective-function]].

* Optimization Problem
:PROPERTIES:
:CUSTOM_ID: optimization-problem
:END:
This sections introduces the problem in the form of the objective function as well MILP constraints. The objective
function is required to allow comparisons between candidate solutions. In the context of this formulation, the objective
function is broken down into two major components as alluded in the introduction: consumption cost, demand cost,
assignment cost, as well as a penalty for undercharging a bus. The constraints ensure that candidate solutions are in
the feasible region. They are composed of a series of equations defined by decision variables which are unknown
variables that are manipulated in the attempt to optimize the objective functions and input variables predefined input
variables that are assumed to be known. Furthermore, the decision variables have components that are directly and
indirectly manipulated. This will be further discussed in [[#sec:decision-variables]].

#+include: "tab/variables.org"

** Parameter Definitions
:PROPERTIES:
:CUSTOM_ID: sec:parameter-definitions
:END:
This section defines the input variables and decision variables used by the system. The input variables are the
parameters that are assumed to be known prior to optimizing the system. The decision variables are the values that the
SA algorithm has the freedom to manipulate. The values produced by the SA algorithm will be interpreted as a candidate
charging solution. This is further described in [[#sec:simulated-annealing]].

*** Input Variables
:PROPERTIES:
:CUSTOM_ID: sec:input-variables
:END:
The input values of any MILP system are defined prior to the solving of the system. They specify initial conditions,
known state properties, etc. Roughly following the order in [[tab:variables]], each variable will be introduced.

$\Delta_i$ is the amount power required to complete the bus route after visit $i$. Because there is no route after the
last visit, the power consumed after the final visit is zero. Formally, let $\Jset_b \subset \Iset$ denote the set of
visit indices for bus $b$, and let $\Jset_b^f$ denote the final visit index for bus $b$. Furthermore, let the set of
final visits for each bus, $b$, such that $\Isetfinal = \{ x \in \Isetfinal \subset \Iset : \forall b \in \Bset, x \in
\Jset_b^f \}$. As mentioned before, the last visit for each bus has no discharge and can be written as $\Delta_{i \in
\Isetfinal} = 0$. The discharge for visit all visits $i \in \{\Iset \setminus \Isetfinal\}$, is defined by $\Delta_i =
\delta_i \cdot \rho_i$ where $\delta_i$ is the amount of energy consumed by the bus per mile and $\rho_i$ is the route
mileage after visit $i$. $\rho_i$ is calculated using $\rho_i = \text{average mph} \cdot (a_{\xi_i} - d_i)$. For the
final visits, $\rho_{i \in \Isetfinal} = 0$. The average MPH is assumed to be 20 miles per hour.

$\alpha_b$ is the initial SOC percentage of bus $b$ at the beginning of the working day. The initial SOC for bus $b$ can
be represented as shown in [[eq:batinit]] where $\kappa_b$ is the battery capacity for bus $b$, $\eta_{i \in \Isetinit}$
indicates the initial charge for bus $b$ where $\Isetinit = \{ x \in \Isetinit \subset \Iset : \forall b \in \Bset, x
\in \Jset_b^0 \}$. The rest of the $\eta_i$ terms are considered decision variables and will be further discussed in
[[#sec:decision-variables]]. $dt_h$ is the discrete time step used for calculating the demand cost. $\epsilon_q$ is the cost
for assigning a charger to queue $q$. This parameter is utilized by the objective function and is further discussed in
[[#sec:objective-function]]. $\xi_i$ represents the next arrival index for bus $b_i$. In other words, given a set of bus
visit IDs $\{ 1,2,3,1\}$, using a starting index of 1, $\xi_1 = 4$. This is found by first identifying tho ID of the
first element in $\Iset_b$, which is 1. The next step is to find the next occurrenc of bus 1 in the sequence. In this
exapmple, the next index for bus 1 is $i= 4$. $a_i$ and $e_i$ are the arrival and departure times of bus visit $i$ to
the station, respectively. $k$ represents the local iteration search for the SA algorithm. This is further discussed in
[[#sec:simulated-annealing]]. Lastly, $r_q$ represents the rate of charge for the charger in queue $q$.

#+name: eq:batinit
#+begin_export latex
\begin{equation}
\label{eq:batinit}
  \eta_{i \in \Isetinit} = \alpha_b \cdot \kappa_b \text{,}
\end{equation}
#+end_export

*** Decision Variables
:PROPERTIES:
:CUSTOM_ID: sec:decision-variables
:END:
Decision variables are the defined by the optimizer and are therefore unknown prior to running the optimization
algorithm. In this case the optimizer is SA. Once SA has been run, each of the decision variables will be specified and
the fitness of the solution will be determined by the objection functions The variables will be broken into two
sections: direct and indirect decision variables. Decision variables that are direct are values that the system has
direct control over and indirect variables are those that are influenced by the direct.

**** Direct Decision Variables
:PROPERTIES:
:CUSTOM_ID: sec:direct-decision-variables
:END:
Decision variables that are direct are variables that can be immediately chosen by SA. The first two variables are $u_i$
and $d_i \; \forall i \in \Iset$. They represent the initial and final charging times. These values must remain within
range of the arrival time and departure time for visit $i$, $[a_i, e_i]$. $\mu_h$ and $theta_h$ are binary decision
variables, $\mu_h, \theta_h \in \{0, 1\}$. $\mu_h = 1$ when $u_i \le dt_h$, and is 0 otherwise. $\theta_h = 1$ when $d_i
\ge dt_h$ and is 0 otherwise. The last direct decision variable is the queue that bus visit $i$ can be placed in to
charge, $v_i \in \Qset$.

**** Indirect Decision Variables
:PROPERTIES:
:CUSTOM_ID: sec:indirect-decision-variables
:END:
Indirect decision variables are variables that are dependent on direct decision variables. For example $\eta_i$ is the
initial charge for visit $i \in \Iset \setminus \Isetfinal$. These variables are chained together per bus by using the
bus identifier, $b$, and next arrival index, $\xi_i$. The initial charges must be chained so that the battery charge can
be calculated per bus as it is charged and discharged over each visit, $[u_i, d_i]$. The concept of chaining the battery
charges together is shown in [[eq:bat-chain]]. The equation states that the charge for bus $i$'s next visit is equal to the
initial charge for visit $i$ plus the charge added to it by charger $v_i$ over duration $s_i = d_i - u_i$ minus the discharge
accumulated over route $i$.

#+name: eq:bat-chain
#+begin_export latex
\begin{equation}
\label{eq:bat-chain}
  \eta_{\xi_i} = \eta_i + r_{v_i}s_i - \Delta_i
\end{equation}
#+end_export

$\iota_h = 1$ when $\mu$ and $\theta$ are both active. $\phi_i$ is a boolean decision variable, $\phi_i \in \{0,1\}$,
that either enables or disables the charge penalty defined in [[#sec:objective-function]]. $\sigma_{ij}$ and $\psi_{ij}$ are
used to indicate whether a visit pair $(i, j)$ overlap the same space as show in [[fig:spacial-and-temporal-constr]]. A
little more formally, [[eq:bus-spat-temp]] describes the relationship that $\sigma_{ij}$ and $\phi_{ij}$ uphold. That is,
for every visit, if the start charge time of either visit $i$ or $j$ is greater than end charge time of the other, then
$\sigma_{ij}$ is active. Similarly, if the queue for visit $i$ and $j$ are different, then $\psi_{ij}$ is active. These
variables will be further elaborated on in [[#sec:constraints]].

#+name: eq:bus-spat-temp
#+begin_export latex
\begin{subequations}
\label{eq:bus-spat-temp}

\begin{equation}
  \sigma_{ij} =
  \begin{cases}
    1 & \text{if } u_i \ge d_j \\
    0 & \text{otherwise}
  \end{cases}
\end{equation}

\begin{equation}
  \psi_{ij} =
  \begin{cases}
    1 & \text{if } v_i \ge v_j \\
    0 & \text{otherwise}
  \end{cases}
\end{equation}

\end{subequations}
#+end_export


$p_d$ is the demand cost of the overall charging schedule. It is calculated after all the decision variables have been
assigned. This is further described in [[#sec:objective-function]].

** Objective Function
:PROPERTIES:
:CUSTOM_ID: sec:objective-function
:END:
The objective function is used to compare the fitness of different candidate solutions against one another. This
objective function takes in input and decision variables to calculate some value of measure. The calculated objective
function value can either be maximized or minimized. The desired option is dependent on the problem to be solved as well
as the formulation of said objective function. Let $J$ represent the objective function. The objective function for this
problem has four main considerations: charger assignment, consumption cost, demand cost, and sufficient charge.

Suppose the objective function is of the form $\text{min } J = \AC + \PC$. $\AC$ is the assignment cost, and $\PC$ is
the power usage cost. The assignment cost represents the costs of assigning a bus to a particular queue as well as the
chosen charging period, $[u_i, d_i]$, as shown in [[eq:ac]]. $v_i \in \Qset$ is the charger index, $u_i$ is the initial
charge time, $d_i$ is the detach time for visit $i$, $\phi_i$ is a binary decision variable, $m$ is the minimum charge
percentage allowed, $\kappa_i$ is the battery capacity for visit $i$, and $\eta_i$ is the charge for $b_i$ when it
arrives for visit $i$.

#+name: eq:ac
#+begin_export latex
\begin{equation}
\label{eq:ac}
\AC = \sum_{i=1}^I \Big(\epsilon_{v_i}s_i + \frac{1}{2} C \phi_i (\eta_i - m \kappa_i)^{2}\Big)
\end{equation}
#+end_export

The first term in the summation represents the calculation of the cost for assigning a bus to queue $q$ (i.e. cost of
using the charger multiplied by the usage time). The second term is the penalty function that is either enabled or
disabled by $\phi_i$ [[cite:&Luenberger2008]]. $\phi_i$ is enabled when the initial charge, $\eta_i$, is less than the
allowed minimum charge, $m\kappa_{b_i}$. This is further discussed in [[#sec:constraints]]. Note that the variables $\phi_i$
and $\eta_i$ are both decision variables that are being multiplied together. This is called a bilinear term. Using a
traditional MILP solver, this would require linearization [[cite:&Rodriguez2013]]; however, because SA handles
nonlinearities easily these bilinear terms will be ignored [[cite:&Radosavljevic2018-jc]].

The demand cost quantifies the amount of power being used over a given period and adjusts the cost accordingly. The
consumption cost calculates the total amount of power being consumed by the chargers. The consumption cost is merely the
summation of all the energy being used over all the active periods for each charger in the time horizon as written in
[[eq:consumption-cost]]. $r_{v_i}$ is the charge rate for the active charger $v_i$ and is multiplied by the time that the
charger will be utilized, $s_i$.

#+name: eq:consumption-cost
#+begin_export latex
\begin{equation}
\label{eq:consumption-cost}
  \sum_{i=1}^I \Big( r_{v_i}s_i \Big)
\end{equation}
#+end_export

The demand cost is calculated based on 15 minute increments (900 s). This cost is also referred to as the peak 15. The
average power used over an arbitrary 15 minute interval is represented by [[eq:p15]].

#+name: eq:p15
#+begin_export latex
\begin{equation}
\label{eq:p15}
p_{15}(t) = 1/900 \int_{t-900}^{t} p(\tau) d\tau
\end{equation}
#+end_export

Worst case must be assumed to always ensure enough power is supplied; therefore, the maximum value found is retained as
represented in [[eq:pmax]].

#+name: eq:pmax
#+begin_export latex
\begin{equation}
\label{eq:pmax}
p_{max}(t) = \text{max}_{\tau \in [0,t]}p_{15}(\tau)
\end{equation}
#+end_export

A fixed minimum threshold, $p_{fix}$, is introduced as a base power rate to be charged at. Let this fixed threshold be
defined as $p_{fix}$. In a similar manner as $p_{max}$, the maximum value is retained. Furthermore, let $s_r$ define the
demand rate which has the units of \(\frac{\$}{kW}\).

#+name: eq:pdem
#+begin_export latex
\begin{equation}
\label{eq:pdem}
p_d(t) = \text{max}(p_{fix},p_{max}(t))s_r
\end{equation}
#+end_export

[[eq:pdem]], again, retains the largest $p_{dem}$ value with a starting fixed value of $p_{fix}$. To write the total power
demand at any discrete time, consider [[eq:discrete-power]]. Let $\omega_h \in \omega$ be the discrete power demand at time step $h$
where $h \in \{ 1, 2, ..., H \} \subset \mathcal{Z}$ and $H = \frac{T}{900}$. For conciseness of notation we will abuse $t_h$ to denote
the time in discrete form (as opposed to $t$ being continuous), let $dt_h = t_h - t_{h-1}$, and $\Hset = \{ 1, 2, ..., H
\}$. Let $\iota_h$ be a binary decision variable that is enabled if charger $v_i \in \Qset$ is enabled in the time frame
$dt_h$. Let the power usage of charger $v_i$ be denoted as $r_{v_i}$.

#+name: eq:discrete-power
#+begin_export latex
\begin{equation}
\label{eq:discrete-power}
  \omega_h = \sum_i^I \iota_h \cdot r_{v_i}
\end{equation}
#+end_export

The average power can be rewritten as $p_{15}^h = \omega_h$, $p_d$ can be rewritten as $p_d^h = \text{max}_{h \in \Hset}
(p_{15}^{h})$, there the $h$ repesents the $h^{\text{th}}$ step. Finally, $p_d^f$ can be written as [[eq:pd-dis]].

#+name: eq:pd-dis
#+begin_export latex
\begin{equation}
\label{eq:pd-dis}
  p_d^h = \text{max}_{h \in \Hset}(p_{fix}, p_{max}^h)s_d
\end{equation}
#+end_export

To write the power cost, [[eq:consumption-cost]] and [[eq:pd-dis]] are added together to create [[eq:pc]].

#+name: eq:pc
#+begin_export latex
\begin{equation}
\label{eq:pc}
\PC = p_d + \sum_{i=1}^I \Big( r_{v_i}s_i \Big)
\end{equation}
#+end_export

** Constraints
:PROPERTIES:
:CUSTOM_ID: sec:constraints
:END:
Now that a method of calculating the fitness of a schedule has been established, a method for determining the
feasibility of a schedule must be defined. Feasible schedules require that the schedule maintain a certain list of
properties. These properties are enforced by a set of constraints derived from the MILP PAP. The constraints must ensure
no overlap temporally or spatially, receives enough charge to complete route after each visit $i$, bus visit $i$ cannot
be over-charged, and departs on time. The aforementioned constraints are shown in [[eq:constraints]].

#+include: "eq/constraints.org"

# Org mode is a little silly and does not take normal referencing syntax. This note is for future reference.

Constraints \ref{seq:c0}-\ref{seq:c4} are the "queuing constraints". They are used to prevent overlapping in both
spatially and temporally as shown in [[fig:spacial-and-temporal-constr]]. The y-axis represents the possible queues for a
bus visit to be placed into, and the x-axis represents the time that can be reserved for each visit. The shaded
rectangles represent time that has been scheduled and the queue allocated for each bus visit. The set of constraints
\ref{seq:c0} - \ref{seq:c4} aim to ensure that these shaded rectangles never overlap.

#+include: "img/spacial-temporal-constr.org"

Constraint \ref{seq:c4} states that the starting service time for bus $j$, $u_j$, must be greater than the starting time
of bus $i$, $u_i$, plus its service time, $s_i$. The last term utilizes big-M notation to activate or deactivate the
constraint. A value of $\sigma_{ij} = 1$ will activate the constraint to ensure that $i$ is complete before $j$ is
allowed to begin being serviced. If $\sigma_{ij} = 0$, then the constraint is of the form $T + u_j + s_j > u_i$
rendering the constraint "inactive" because $u_i$ cannot be larger than $d_i$. This effectively allows the charging
windows of the vehicle to overlap.

Similarly, $\phi_{ij}$ determines whether the vehicles will be charging in the same queue. If $\phi_{ij} = 1$ then
\eqref{seq:c1} is rendered active and vehicle $i$ and $j$ must be charging in different queues. If $\phi_{ij} = 0$ then
the constraint is deactivated and the vehicle queue assignments may be the same.

\ref{seq:c5} calculates the discharge for the route after visit $i$. \ref{seq:c6} forms describes the service time of
the bus. \ref{seq:c7} calculates the initial charge for the next visit for bus $b_i$. \ref{seq:c7} ensures that the bus
is not being over-charged. \ref{seq:c9} and \ref{seq:c10} are used to enable and disable the penalty method in [[eq:ac]].
This is done by checking if the initial charge for visit $i$ is greater than or equal to the minimum allowed charge.
\ref{seq:c10} ensures the continuity of the times (i.e. the arrival time is less than the initial charge which is less
than the detach time which is less than the time the bus exits the station and all must be less than the time horizon).

The last set of constraints \ref{seq:c13} - \ref{seq:c17} set the rules for the decision variable $\iota_h$.
\ref{seq:c13} and \ref{seq:c14} ensure that the initial charge time for visit $i$, $u_i$, is greater than the discrete
time, $900 \cdot h$, being checked. Similarly, \ref{seq:c15} and \ref{seq:c16} ensure that the final charge time, $d_i$,
is less than the next discrete time step, $dt_h$. The final constraint \ref{sec:c17} is the discrete representation of
whether charger $v_i \in \Qset$ is active.

* Simulated Annealing
:PROPERTIES:
:CUSTOM_ID: sec:simulated-annealing
:END:
SA is an exploitation oriented, single-solution based (as compared to population based) metaheuristic approach in which
its main advantage is its simplicity both theoretically and in its implementation as well its inherit ability to
overcome nonlinearities [[cite:&Gendreau2018-pw;&Radosavljevic2018-jc]]. This model is named after its analogized process
where a crystalline solid is heated then allowed to cool very slowly until it achieves its most regular possible crystal
lattice configuration [[cite:&Henderson]]. There are five key components to SA: initial temperature, cooling schedule
(temperature function), generation mechanism, acceptance criteria, local search iteration count (temperature change
counter) [[cite:&Keller_2019]].

** Cooling Equation (Experimental)
:PROPERTIES:
:CUSTOM_ID: cooling-equation-experimental
:END:
The initial temperature and cooling schedule are used to regulate the speed at which the solution attempts to converge
to the best known solution. When the temperature is high, SA encourages exploration. As it cools down (in accordance to
the cooling schedule), it begins to encourage local exploitation of the solution [[cite:&Rutenbar_1989;&Henderson]]. There
are three basic types of cooling equations as shown in [[fig:cool]] [[cite:&Keller_2019]]. The different types merely dictate
the rate at which the algorithm progressively disallows exploration. A linear cooling schedule is defined by [[eq:cool0]].

#+name: eq:cool0
#+begin_export latex
\begin{equation}
\label{eq:cool0}
\Tau[n] = \Tau[n-1] - \Delta_0
\end{equation}
#+end_export

with $\Tau[0] = \Tau_0$ and $\Delta_0 = 1/2\; C^\circ$ in [[fig:cool]]. A geometric cooling schedule is mostly used in
practice [[cite:&Keller_2019]]. It is defined by [[eq:cool1]].

#+name: eq:cool1
#+begin_export latex
\begin{equation}
\label{eq:cool1}
\Tau[n] = \alpha \Tau[n-1]
\end{equation}
#+end_export

where $\alpha = 0.995$ in [[fig:cool]]. An Exponential cooling schedule is defined by the difference equation is defined as
[[eq:cool2]].

#+name: eq:cool2
#+begin_export latex
\begin{equation}
\label{eq:cool2}
\Tau[n] = e^{\beta}\Tau[n-1]
\end{equation}
#+end_export

where $\beta = 0.01$ in [[fig:cool]]. The initial temperature, $T_0$, in the case of [[fig:cool]], is set to $500^\circ\; C$ and
each schedule's final temperature is $1\; C^\circ$.

#+name: fig:cool
#+ATTR_ORG: :width 200
#+ATTR_LATEX: :width 0.5\textwidth
#+caption: Cooling equations \label{fig:cool}
[[file:img/cool-func.jpg]]

** Acceptance Criteria
:PROPERTIES:
:CUSTOM_ID: sec:acceptance
:END:
Acceptance criteria describes the method to accept or reject a given candidate solution. In SA, if a new candidate
solution is more fit than the currently stored solution it is always accepted as the new solution. However, within SA,
worse candidate solutions may be accepted as the new solution. The probability of accepting the candidate solution is
described by the function $\exp(-\frac{J(x) - J(x')}{\Tau})$ where $J(\cdot)$ is the objective functions described in
[[#sec:objective-function]]. The probability of acceptance is a function of the cooling equation just described and
difference of the current solution and a new candidate solution. Let $\Delta E \equiv J(x) - J(x')$ where $x$ is the
current solution and $x'$ is the new candidate solution. The probability of acceptance of $x'$ is defined by
[[eq:candaccept]] [[cite:&Keller_2019]].

#+name: eq:candaccept
#+begin_export latex
\begin{equation}
\label{eq:candaccept}
f(x,x',T) =
\begin{cases}
  1                 & \Delta E > 0 \\
  e^{- \frac{\Delta E}{T}} & \text{otherwise}
\end{cases}
\end{equation}
#+end_export

** Generation Mechanisms
:PROPERTIES:
:CUSTOM_ID: sec:generators
:END:
Generation mechanisms in SA are used to generate random solutions to propose to the optimizer, these are known as
candidate solutions. In the case of the problem statement made in [[#sec:problem-description]], five generation mechanism
shall be used: new visit, slide visit, new charger, remove, new window. The purpose of each of these generators is to
assign new visits to a charger, adjust a bus visits initial and final charge time within the same time frame/queue,
remove a bus from a charger, and place a bus visit into a new time slot/queue. Each generator will be discussed in more
detail in [[#sec:generators]].

These generator mechanisms will in turn be utilized by three wrapper functions. The purpose of the route generation to
create a set of bus route data to feed to the SA algorithm. Although, strictly speaking, is not a part of the SA
algorithm. It is vital in specifying the initial conditions and "setting the stage" for the SA algorithm to solve. The
schedule generation is to used create candidate solutions for SA to compare with other solutions, and the perturb
schedule generator is used to take a candidate solution and alter it slightly in an attempt to fall into a global/local
minimum.

*** Generator Input/Output
:PROPERTIES:
:CUSTOM_ID: sec:generator-input-output
:END:
This section discusses in detail the expected inputs and output of each generator. It is important to discuss these
parameters in order to have an understanding of the generating algorithms derived. The input consists of the bus visit
index of interest, information about the current state of arrivals, $\I$, and the current state of the chargers'
availability, $\C$. The output of each generator affects the tuple of decision variables $(v_i, u_i, d_i) \subset \I_i$.

**** Generator Input
Each generator has the tuple input of ($i, \I, \C$) where $i$ is the visit index, $\I_i$ is the tuple $\visit$
([[#sec:problem-description]]), that describes the set of visits generated by the route generation algorithm
([[#sec:route-gen]]), and $\C$ is the set that describes the availability for all chargers $q \in \Qset$. In other words, $\C$
defines the set of times when the chargers are not being utilized or are "inactive".

To derive $\C$, consider its inverse, $\C'$, which is the set of "active" time periods for each charger, $\C' = \bigcup
\{\C_q' : q \in \mathcal{Q}\}$ where $\C_q' \subset \C'$ describes the active times for chagrer $q$. Focusing on an individual charger,
consider $\C_q'$ before a schedule has been imposed upon it, $\C_q' \in \varnothing$. In other words, no buses have been
assigned to be charged over the time period of $[u_i, d_i]$. After the scheduling process is complete, $\C_q'$ will have
a set of active periods of the form $\C_q' \in \{[u_j, d_j]: j \in \Jsetq \}$ where $\Jsetq \subset \mathcal{I}$. For $\C_q'$ to be of
value, its compliment is to be found, $\C_q$.

To determine the inverse of $\C_q'$, begin by noting $\C_q' \bigcap \{[u_j, d_j] : j \in \Jsetq\} = \varnothing$, is said to be
disjoint [[cite:&NaiveHalmos]]. The inverse of a disjoint set can be found by the De Morgan Law as shown in [[eq:demorgan]].
Using [[eq:demorgan]], the set of inactive periods can be written as $\C_q \equiv \bigcup \{[u_j, d_j]': j \in \Jsetq\}$. Let $\Sol$
denote the tuple $\Sol \equiv (i, \I, \C)$.

#+name: eq:demorgan
#+begin_export latex
\begin{equation}
\label{eq:demorgan}
(A \cap B)' = A' \cup B'
\end{equation}
#+end_export

**** Generator Output
The output is a modified visit, noted as $\I_i'$. In actuality only the decision variables are being altered which is a
subset of $\I_i$. Let this subset be defined by $x_i' \equiv (v_i, u_i, d_i) \subset \I_i$ which is the chosen queue, initial
charge time, and detach time from the generator, $(v_i, u_i, d_i)$. The nature of SA implies that the generators have a
sense of randomness. Because of that, some of the generators may have multiple choices for what $x_i'$ may be. Let the
set of candidates for the output be defined as $x_i' \in X_i'$. Furthermore, set the set of candidate visits be denoted as
$\I_i' \in \I'$.

*** Generators
:PROPERTIES:
:CUSTOM_ID: sec:generators
:END:
This section describes and outlines the algorithm pool for the different generator types that are utilized in the
wrapper functions. Note that to satisfy constraints, $B$ extra idle queues that provide no power to the bus. Because of
this, the set of queues is fully defined as $q \in \{1,..., Q, Q+1,..., Q+B\}$ where $Q$ is the total amount of chargers
and $b$ is the bus ID. The use case for this is for when a bus is not to be placed on a charger, it will be placed in
the queue, $v_i \in \{Q+1,..., Q+B\}$, which will satisfy the constraints above while allowing the bus to be "set aside"
while others charge.

**** New visit
:PROPERTIES:
:CUSTOM_ID: new-visit
:END:
The new visit generator describes the process of moving bus $b$ from the idle queue, $v_i \in \{Q+1,..., Q+B\}$ to a valid
charging queue, $v_i \in \{1,..., Q\}$. Lines 2-4 extracts the visit, $i$, arrival time, $a_i$, and departure time, $e_i$.
Note that in subsequent algorithms these lines will be omitted for conciseness. Line 5 loops through the inactive time
periods that contain the time the bus is at the station, $[a_i, e_i]$. Line 6 verifies that the inactive period selected
is valid and returns a random charging time, $[u_i, d_i]$, if it is. Line 7 returns the new visit.

#+name: alg:new-visit
#+begin_export latex
\begin{algorithm}[H]
\caption{New visit algorithm}
\label{alg:new-visit}
    \LinesNumbered
    \TitleOfAlgo{New Visit}
    \KwIn{($\Sol$)}
    \KwOut{$\I_i'$}

    \SetKwFunction{Union}{Union}
    \SetKwFunction{findFreeTime}{findFreeTime}

    \Begin
    {
        $i    \leftarrow \{i: i \in \Sol \}$ \tcc*{The index of the visit $i$}
        $a_i  \leftarrow \{ a_i \in \I_i : \I_i \in \I \subset \Sol \}$ \tcc*{Get the arrival time for visit $i$}
        $e_i  \leftarrow \{ e_i \in \I_i : \I_i \in \I \subset \Sol \}$ \tcc*{Get the departure time for visit $i$}

        \tcc{Randomly select a free time, $j$, from any charger $q \in \Q$ that is within the time frame $[a_i e_i]$}
        \While {$C_q^j \in \{[a_i, e_i]\} \subset \U_{\C}$}
        {
            \If(\tcc*[f]{If there is time available in $C_q^j$}){$x_i' \leftarrow\findFreeTime{$C_q^j$, ($a_i, e_i$)} $\not\in \varnothing$}
            {
                \Return{$\I_i' \leftarrow x_i'$} \tcc*[f]{Return visit}
            }
        }
    }
\end{algorithm}
#+end_export

The algorithm to find free time is defined in [[alg:find-free-time]]. $L$ and $U$ are the lower and upper bound of the time
between scheduled times. The possible use cases are depicted in [[fig:find-free]]. In each case depicted by [[fig:find-free]],
the red line shows the arrival and departure time for an arbitrary bus visit, $i$. The blue lines indicate reigons in
which charger $q$ is active. $C \in \C_q \subset \C$ represents one of the regions between the blue lines, $[L, U]$ which stand
for the lower and upper portions of the regions, respectively. The output of [[alg:find-free-time]] is a range for which the
bus may be charged and the empty set if it cannot. As an example, consider a bus that is in the process of being
scheduled and it encounters a situation similar to \autoref{subfig:egu}. That is, the only scheduling constraint is that
the arrival time is before charger $q$ is available to charge the bus. Therefore, the bus must wait intil $L$ before
changer $q$ may charge it. Furthermore, the range that $u_i$ must be selected from is $[L,e]$.

#+include: "img/find-free.org"

#+name: alg:find-free-time
#+begin_export latex
\begin{algorithm}[H]
\caption{Find free time algorithm searches and returns the available time frames}
\label{alg:find-free-time}
    \LinesNumbered
    \TitleOfAlgo{Find Free Time}
    \KwIn{$(L,U,a,e)$}
    \KwOut{$(u,d)$}

    \Begin
    {
        \If(\tcc*[f]{If $L < a < e < U]$ (\autoref{subfig:sandwich})}){$L \leq a$ and $U \geq e$}
        {
                u $\leftarrow$ $\U_{[a,e]}$\;
                d $\leftarrow$ $\U_{[u,e]}$\;
        }
        \ElseIf(\tcc*[f]{Else if $a < L < e < U$ (\autoref{subfig:all})}){$L > a$ and $U \geq e$}
        {
                u $\leftarrow$ $\U_{[L,e]}$\;
                d $\leftarrow$ $\U_{[u,e]}$\;
        }
        \ElseIf(\tcc*[f]{Else if $L < a < U < e$ (\autoref{subfig:egu})}){$L \leq a$ and $U < e$}
        {
                u $\leftarrow$ $\U_{[a,U]}$\;
                d $\leftarrow$ $\U_{[u,U]}$\;
        }
        \ElseIf(\tcc*[f]{Else if $a \leq u \leq d \leq L$ or $U \leq a \leq d \leq e$ (\autoref{subfig:invertsandwhich})}){$L > a$ and $U < e$}
        {
                u $\leftarrow$ $\U_{[a,L], [U,e]}$\;
                d $\leftarrow$ $\U_{[u,L], [u,e]}$\;
        }
        \Else(\tcc*[f]{Otherwise the bus cannot be scheduled in this time frame (\autoref{subfig:invalid})})
        {
                u $\leftarrow$ $\varnothing$\;
                d $\leftarrow$ $\varnothing$\;
        }

        \Return{(u,d)}
    }
\end{algorithm}
#+end_export

**** Slide visit
:PROPERTIES:
:CUSTOM_ID: slide-visit
:END:
Slide visit is used for buses that have already been scheduled. Because of the constraint \ref{seq:c10} there may be
some room to move $u_i$ and $d_i$ within the window $[a_i, e_i]$. Two new values, $u_i$ and $d_i$ are selected with a
uniform distribution to satisfy the constraint $a_i \leq u_i \leq d_i \leq e_i$. Line 2 randomly loops through the other
inactive time frames from charger $v_i$ that is within the time that the bus is at the station, $[a_i, e_i]$. Line 3
verifies the time frame previously selected and returns a new charging time. Line 4 returns the new visit.

#+name: alg:slide-visit
#+begin_export latex
\begin{algorithm}[H]
\caption{Slide Visit Algorithm}
\label{alg:slide-visit}
    \LinesNumbered
    \TitleOfAlgo{Slide Visit}
    \KwIn{$\Sol$}
    \KwOut{$\I_i'$}

    \Begin
    {
        \tcc{Randomly select an inactive time frame, $j$, from charger $v_i$ that is within the time frame $[a_i, e_i]$}
        \While {$C_q^j \in \{[a_i, e_i]\} \subset \U_{\C_{v_i}}$}
        {
            \If(\tcc*[f]{If there is time available in $C_q^j$}){$x_i' \rightarrow$ \findFreeTime{$C_q^j$, ($a_i, e_i$)} $\not\in \varnothing$}
            {
                \Return{$\I_i \leftarrow x_i'$} \tcc*[f]{Return visit}
            }
        }
    }
\end{algorithm}
#+end_export

**** New charger
:PROPERTIES:
:CUSTOM_ID: new-charger
:END:
The new charger generator takes a visit $\I_i$ and changes the charger it is on while maintianing the same charge time,
$[u_i, d_i]$. Similarly to [[alg:new-visit]], the new candidate, $x_i'$, must be checked before being added to the set
$X_i'$. Line 2 randomly loops through any time frame from any charger, $C_q^j$, that is within the time frame that the
bus is at the station, $[a_i, e_i]$. Line 3 verifies the selection and line 4 returns the new visit.

#+name: alg:new-charger
#+begin_export latex
\begin{algorithm}[H]
\caption{New Charger Algorithm}
\label{alg:new-charger}
    \LinesNumbered
    \TitleOfAlgo{New Charger}
    \KwIn{$\Sol$}
    \KwOut{$\I_i'$}

    \Begin
    {
        \tcc{Randomly select an inactive time frame, $j$, from any charger $q \in \Qset$ that is within the time frame $[a_i, e_i]$}
        \While {$C_q^j \in \{[a_i, e_i] \} \subset \U_{\C}$}
        {
            \If (\tcc*[f]{If the charge time is within the region $[L,U]$}) {$L \leq u$ \And $U \geq e$}
            {
                \Return{$\I_i \leftarrow x_i'$} \tcc*[f]{Return visit}
            }
        }

    }
\end{algorithm}
#+end_export

**** Remove
:PROPERTIES:
:CUSTOM_ID: sec:remove
:END:
The remove generator simply removes a bus from a charger queue and places it in its idle queue, \(v_i \in
\{Q,...,Q+B\}\).

#+name:alg:remove
#+begin_export latex
\begin{algorithm}[H]
\caption{Remove algorithm}
\label{alg:remove}
    \LinesNumbered
    \TitleOfAlgo{Remove}
    \KwIn{$\Sol$}
    \KwOut{$\I_i'$}

    \Begin
    {
       \Return{$(Q+b,a_i,e_i)$}
    }
\end{algorithm}
#+end_export

**** New Window
:PROPERTIES:
:CUSTOM_ID: sec:new-visit
:END:
New window is a combination of the remove and then new visit generators ([[#sec:remove]] and [[#sec:new-visit]]). By this it is
meant that current scheduled tuple $(v_i, u_i, d_i)$ is removed and added back in as if it were a new visit.

#+name: alg:new-window
#+begin_export latex
\begin{algorithm}[H]
\caption{New window algorithm}
\label{alg:new-window}
    \LinesNumbered
    \TitleOfAlgo{New Window}
    \KwIn{$\Sol$}
    \KwOut{$\I$}

    \Begin
    {
        \SetKwFunction{NewVisit}{NewVisit}
        \SetKwFunction{Remove}{Remove}

        $x_i' \leftarrow$ \Remove{$v,u,d$} \tcc*{Remove visit $i$ from its charger}
        $x_i' \leftarrow$ \NewVisit{$x_i'$} \tcc*{Add visit $i$ back in randomly}

        \Return{$(v,u,d)$}
    }
\end{algorithm}
#+end_export

*** Generator Wrappers
:PROPERTIES:
:CUSTOM_ID: generator-wrappers
:END:
This section covers the algorithms utilized to select and execute different generation processes for the SA process. The
generator wrappers are the method immediately called by SA. Each wrapper utilizes the generators previously described
and returns either metadata about the bus routes or a new valid charger schedule.

**** Route Generation
:PROPERTIES:
:CUSTOM_ID: sec:route-gen
:END:
The objective of route generation is to create a set of metadata about bus routes given the information in
[[fig:routeyaml]]. Specifically, the objective is to generate the input variables in $\I$ for $I$ visits with $B$ buses.
Each visit will have an initial charge (specified for first visit only), arrival time, departure and time. In other
words, $y_i \equiv (a_i, e_i) \subset \I \forall i \in \Iset$ and each bus will be initialed with the SOC defined by
[[eq:batinit]].

In essence the logic is as follows: Generate $B$ random numbers that add up to $I$ visits (with a minimum amount of
visits set for each bus). For each bus and for each visit, set a departure time that is between the range [min_rest,
nmax_rest] ([[fig:routeyaml]]), set the next arrival time to be $j \cdot \frac{T}{\text{J}}$ where $j$ is the $j^{th}$ visit
for bus $b$ and $J$ is the total number of visits for bus $b$. Finally, calculate the amount of discharge from the
previous arrival to the next departure time as defined by [[eq:batinit]].

The metadata in [[fig:routeyaml]] will be denoted by $\M$ visually represents the YAML file used. This data contains all the
parameters required to create a set of bus routes. Each of the cells will now be described from left to right, top to
bottom. =time_horizon= represents the amount of time that the routes will be running for in hours. =schedule= contains
the parameters that directly affect the generated set of routes. Some of the parameters in the YAML have already been
defined in this paper, but go under a different name in the file. These parameters are: =num_bus= $\equiv B$,
=num_visit= $\equiv I$, and =bat_capacity= $\equiv \kappa$. =max_charge= and =min_charge= represent the maximum and
minimum percentages that the buses may be charged to. =max_rest= and =min_rest= represent the maximum and minimum times
that buses may remain at the station, and =max_route= and =min_route= represent the maximum and minimum lengths that bus
routes may be.

#+name: fig:routeyaml
#+caption: Route YAML file with example data
#+ATTR_ORG: :width 200
#+ATTR_LATEX: :width 0.5\textwidth
[[file:img/route_yaml.png]]

#+name: alg:route-generation
#+begin_export latex
\begin{algorithm}[H]
\caption{Route generation algorithm}
\label{alg:route-generation}
    \LinesNumbered
    \TitleOfAlgo{RouteGeneration}
    \KwIn{$\M$}
    \KwOut{$\I$}

    \SetKwFunction{Union}{Union}
    \SetKwFunction{DepartureTime}{DepartureTime}
    \SetKwFunction{ArrivalTimeNew}{ArrivalTimeNew}
    \SetKwFunction{Discharge}{Discharge}
    \SetKwFunction{SortByArrival}{SortByArrival}
    \SetKwFunction{Feasible}{Feasible}

    \Begin
    {
        \While{\Not schedule-created}
        {
            arrival-new $\leftarrow$ 0.0\;
            arrival-old $\leftarrow$ 0.0\;
            departure-time $\leftarrow$ 0.0\;
            schedule-created $\leftarrow$ false\;

            \ForEach{b $\in$ B}
            {
                \ForEach{n $\in\; J_b$}
                {
                    arrival-old $\leftarrow$ arrival-new\;

                    \If{j = $J_b$}{final-visit = true\;}
                    \Else{final-visit = false\;}

                    departure-time $\leftarrow$ \DepartureTime{arrival-old, final-visit}\;
                    arrival-new $\leftarrow$ current-visit*$\frac{T}{J_b}$\;
                    discharge $\leftarrow$ discharge-rate*(next-arrival, depart-time)    \;
                    \Union{$\I$, (arrival-old, departure-time, discharge)}\;
                }
            }

            schedule-created $\leftarrow$ \Feasible{$\I$}\;
            \SortByArrival{$\I$}\;
        }
        \Return{$\I$}
    }
\end{algorithm}
#+end_export

The =Departure= algorithm is shown in [[alg:departure-time]], and the =Feasible= method is used to determine if
the generated schedule is valid (conditions covered in [[#sec:constraints]]). This is done to generate a schedule that is in
the solution space.

#+name: alg:departure-time
#+begin_export latex
\begin{algorithm}[H]
\caption{Departure time algorithm}
\label{alg:departure-time}

    \LinesNumbered
    \TitleOfAlgo{DepartureTime}
    \KwIn{(arrival-old, final-visit)}
    \KwOut{depart}

    \Begin
    {
        \If{final-visit}
        {
            depart $\leftarrow$ T\;
        }
        \Else
        {
            depart $\leftarrow$ arrival-old + $\U_{[\text{min-rest},\text{max-rest}]}$\;
        }

        \Return{depart}
    }
\end{algorithm}
#+end_export

**** Schedule Generation
:PROPERTIES:
:CUSTOM_ID: schedule-generation
:END:
The objective of this generator is to generate a candidate solution to the given schedule. To generate a candidate
solution, the generator is given $\I$, a bus is picked at random, $b \in \Bset$, then a random visit is picked. The new
visit generator ([[alg:new-visit]]) is then utilized. This process is repeated for each visit. This algorithm is summarized
in [[alg:schedule-generation]].

#+name: alg:schedule-generation
#+begin_export latex
\begin{algorithm}[H]
\caption{Schedule generation algorithm}
\label{alg:schedule-generation}
    \LinesNumbered
    \TitleOfAlgo{ScheduleGeneration}
    \KwIn{$\I$, $\C$}
    \KwOut{$\I_i'$}

    \SetKwFunction{Union}{Union}
    \SetKwFunction{NewVisit}{NewVisit}

    \Begin
    {
        $\I \leftarrow \; \varnothing$\;
        \For {i in I}
        {
            $b \leftarrow\; \U_{\Bset}$\;
            $i\leftarrow\; \U_{\Iset}$\;
            $\I_i \leftarrow \NewVisit{(visit.a, visit.e)}$\;
            Update $\C_q$ with information in $I_i'$\;
        }
            \Return{$\I$}
    }
\end{algorithm}
#+end_export

**** Perturb Schedule
:PROPERTIES:
:CUSTOM_ID: tweak-schedule
:END:
As described in SA, local searches are also employed to try and exploit a given solution [[cite:&Radosavljevic2018-jc]]. The
method that will be employed to exploit the given solution is as follows: pick a bus, pick a visit, pick a generator.
The algorithm is outlined in [[alg:perturb-schedule]].

#+name: alg:perturb-schedule
#+begin_export latex
\begin{algorithm}[H]
\caption{Perturb schedule algorithm}
\label{alg:perturb-schedule}

    \LinesNumbered
    \TitleOfAlgo{PerturbSchedule}
    \KwIn{$\I$, $\C$}
    \KwOut{$\I_i'$}

    \SetKwFunction{GeneratorCallback}{GeneratorCallback}

    \Begin
    {
        Select the bus $b \leftarrow\; \U_{\Bset}$\;
        Select the visit $j \leftarrow\; \U_{\Jset_b}$\;
        generator $\leftarrow\; \U_{[1,generator-count]}$\;
        $\I_i \leftarrow$ \GeneratorCallback[generator]{($j, \I, \C$)}\;
        Update $\C_q$ with information in $I_i'$\;
        \Return{$\I_i$}
    }
\end{algorithm}
#+end_export

* Optimization Algorithm
:PROPERTIES:
:CUSTOM_ID: optimization-algorithm
:END:
This final section combines the generation algorithms and the optimization problem into a single algorithm. It begins
with an introduction to a general SA algorithm which will be used to springboard into the construction of the SA PAP
algorithm. For the case of the pseudo SA algorithm to be presented, the notation pesented will be self-contained and not
related to any of the variables presented for SA PAP thus far. Consider [[alg:sa-pseudo]] [[cite:&Henderson]]. $\omega$ and $\omega'$ are
the current solution and the candidate solution, respectively. $t_k$ is the temperature cooling schedule, $T$ is the
initial temperature that will iterate until $k = K$. $M_k$ is the repetition counter, it defines the number of
iterations to execute for each temperture $t_k$.

The algorithm behaves as follows: initialize the SA algorithm with an initial solution, temperature schedule, and
repetition schedule. The first loops until $T = t_K$, the second loop finished whin $m = M_k$. For each loop, create a
new solution, calculate the difference in the fitness of $\omega$ and $\omega'$. Update $\omega$ with $\omega'$ if the candidate solution is
better. Update $\omega$ with $\omega'$ with probability $e^{\frac{-\Delta_{\omega , \omega'}}{t_k}}$ if the candidate solution is worse than the
current solution. This is repeated until the stopping criteria is met.

#+name: alg:sa-pseudo
#+begin_export latex
\begin{algorithm}[H]
\caption{Pseudo-code for SA}
\label{alg:sa-pseudo}
    \LinesNumbered
    \TitleOfAlgo{SA Pseudo-Code}

    \SetKwFunction{f}{f}
    \Begin
    {
        Select an initial solution $\omega \in W$\;
        Select the temperature change counter $k=0$\;
        Select a temperature cooling schedule $t_k$\;
        Select an initial temperature $T = t_0 \geq 0$\;
        Set the initial inactive time for each charger to the time horizon $\forall q \in \Qset : \C_q \in \{[0,T]\}$\;
        Select a repetition schedule $M_k$, that defines the number of iterations executed at each temerature $t_k$\;

        \While{Stopping criterion not met}
        {
            Set repetition counter $m \rightarrow 0$\;
            \While{$m = M_k$}
            {
                Generate a new solution $\omega' \in N(\omega)$\;
                Calculate $\Delta_{\omega,\omega'} \rightarrow$ \f{$\omega'$} - \f{$\omega$}\;
                \If{$\Delta_{\omega , \omega'} \le 0$}{$\omega \rightarrow \omega'$}
                \If{$\Delta_{\omega , \omega'} > 0$}{$\omega \rightarrow \omega'$ with probability $e^{\frac{-\Delta_{\omega , \omega'}}{t_k}}$}
                $m \rightarrow m+1$\;
            }

        $k \rightarrow k+1$\;
        }
    }
\end{algorithm}
#+end_export

The objective now is to outline SA-PAP in [[alg:sa-pap]]. Lines 2-4 initialize the SA algorithm by
defining the initial temperature, selecting the cooling schedule, and setting the repetition schedule. Line 5 loops
through each of the step in the temperature schedule $\Tau \in \{ \Tau_0, \Tau_1, ..., \Tau_m \}$. Lines 6 and 7
generate a new solution and calculates its fitness. $\nu$ in this context is defined as $\nu = (u, d, v, \et)$ Lines 8
through 13 updates the solution depending on if the new solution is better or worse than the previous solution. Line 14
iterates through the repetition schedule, $k \in \{1, 2, ..., K\}$. Lines 15-23 perturbs the previously generated
solution, calculates its fitness, and updates the current solution with the candidate solution depending on the fitness.

#+name: alg:sa-pap
#+begin_export latex
\begin{algorithm}[H]
\caption{Simulated annealing approach to the position allocation problem}
\label{alg:sa-pap}
    \LinesNumbered
    \TitleOfAlgo{SA PAP}
    \KwIn{$\I$}
    \KwOut{$\I'$}

    \SetKwFunction{CoolingEquation}{CoolingEquation}
    \SetKwFunction{ScheduleGeneration}{ScheduleGeneration}
    \SetKwFunction{PerturbSchedule}{PerturbSchedule}
    \SetKwFunction{J}{J}

    \Begin
    {
        Initialize temperature $\Tau_0$\;
        Select cooling equation $\Tau_{M} \leftarrow$ \CoolingEquation{$\Tau_0$}\;
        Set a repetition schedule $K$\;

        \For{$\Tau_m \in \{\Tau_0, \Tau_1, ..., \Tau_M\}$}
        {
            Generate a new solution $\upsilon' \in Y \leftarrow$ \ScheduleGeneration{$\I$}\;
            Calculate $\Nu_{\upsilon, \upsilon'} = $ \J{$\upsilon'$}  - \J{$\upsilon$}\;
            \If{$\Nu_{\upsilon, \upsilon'} \le 0$}{$\upsilon \leftarrow \upsilon'$}
            \If{$\Nu_{\upsilon, \upsilon'} \le 0$}{$\upsilon \leftarrow \upsilon'$ with probability $e^{\frac{\Nu_{\upsilon, \upsilon'}}{\Tau_m}}$}

            \For{$k \in \{1, 2, ..., K\}$}
            {
                Perturb the solution and reassess $\upsilon' \in Y \leftarrow$ \PerturbSchedule{$\I$}\;
                Calculate $\Nu_{\upsilon, \upsilon'} = $ \J{$\upsilon'$}  - \J{$\upsilon$}\;
                \If{$\Nu_{\upsilon, \upsilon'} \le 0$}{$\upsilon \leftarrow \upsilon'$}
                \If{$\Nu_{\upsilon, \upsilon'} \le 0$}{$\upsilon \leftarrow \upsilon'$ with probability $e^{\frac{\Nu_{\upsilon, \upsilon'}}{\Tau_m}}$}
            } % For k
        }     % For \Tau
    }         % Begin
\end{algorithm}
#+end_export

bibliography:main.bib
bibliographystyle:plain
# \bibliographystyle{plain}
# \bibliography{main}

#  LocalWords:  SA
